// raylib_gen.dist - line-based raylib.h inventory/skeleton generator

sstr = (v){ if (v == null) { return ""; } return "" + v; };

collapse_ws = (s){
  s = sstr(s);
  out = "";
  i = 0;
  n = len(s);
  was = 0;
  while (i < n) {
    ch = s.substr(i, 1);
    if (ch == " " || ch == "\t" || ch == "\r" || ch == "\n") {
      if (was == 0) { out = out + " "; was = 1; }
    } else {
      out = out + ch;
      was = 0;
    }
    i = i + 1;
  }
  return out.trim();
};

find_from = (s, pat, from){
  s = sstr(s);
  pat = sstr(pat);
  i = from;
  n = len(s);
  m = len(pat);
  if (m == 0) { return from; }
  last = n - m;
  while (i <= last) {
    if (s.substr(i, m) == pat) { return i; }
    i = i + 1;
  }
  return -1;
};

split_words = (s){
  out = {};
  raw = collapse_ws(s).split(" ");
  i = 0;
  while (i < raw.size) {
    p = raw[i];
    if (p != null && len(p) > 0) { out.push(p.copy()); }
    i = i + 1;
  }
  return out;
};

join = (items, sep){
  out = "";
  i = 0;
  while (i < items.size) {
    if (i > 0) { out = out + sep; }
    out = out + items[i];
    i = i + 1;
  }
  return out;
};

split_top = (s, delim){
  s = sstr(s);
  out = {};
  part = "";
  i = 0;
  n = len(s);
  dp = 0;
  db = 0;
  while (i < n) {
    ch = s.substr(i, 1);
    if (ch == "(") { dp = dp + 1; }
    else if (ch == ")" && dp > 0) { dp = dp - 1; }
    else if (ch == "[") { db = db + 1; }
    else if (ch == "]" && db > 0) { db = db - 1; }

    if (ch == delim && dp == 0 && db == 0) {
      out.push(part.trim().copy());
      part = "";
      i = i + 1;
      continue;
    }

    part = part + ch;
    i = i + 1;
  }
  if (len(part.trim()) > 0) { out.push(part.trim().copy()); }
  return out;
};

json_escape = (s){
  s = sstr(s);
  out = "";
  i = 0;
  n = len(s);
  while (i < n) {
    ch = s.substr(i, 1);
    if (ch == "\\") { out = out + "\\\\"; }
    else if (ch == "\"") { out = out + "\\\""; }
    else if (ch == "\n") { out = out + "\\n"; }
    else if (ch == "\r") { out = out + "\\r"; }
    else if (ch == "\t") { out = out + "\\t"; }
    else { out = out + ch; }
    i = i + 1;
  }
  return out;
};

jq = (s){ return "\"" + json_escape(s) + "\""; };

is_char_ptr = (t){
  k = collapse_ws(t).lower().replaceAll(" ", "");
  return k == "char*" || k == "constchar*" || k == "char*const" || k == "constchar*const";
};

is_primitive = (t){
  k = collapse_ws(t).lower().replaceAll(" ", "");
  while (k.startsWith("const")) { k = k.substr(5, len(k) - 5); }
  if (find_from(k, "*", 0) >= 0) { return is_char_ptr(k); }
  return k == "void" || k == "bool" || k == "char" || k == "short" || k == "int" || k == "long" ||
         k == "unsigned" || k == "unsignedint" || k == "unsignedlong" || k == "float" || k == "double" || k == "size_t";
};

has_named_type = (t, known){
  if (find_from(t, "struct ", 0) >= 0) { return 1; }
  x = t.replaceAll("*", " ").replaceAll("[", " ").replaceAll("]", " ");
  ws = split_words(x);
  i = 0;
  while (i < ws.size) {
    w = ws[i];
    wl = w.lower();
    if (wl == "const" || wl == "unsigned" || wl == "signed" || wl == "struct" || wl == "volatile") { i = i + 1; continue; }
    if (known_has(known, w) == 1) { return 1; }
    if (len(w) > 0) {
      c = w.substr(0, 1);
      if (c.upper() == c && c.lower() != c) { return 1; }
    }
    i = i + 1;
  }
  return 0;
};

module_of = (name){
  i = 1;
  while (i < len(name)) {
    a = name.substr(i - 1, 1);
    b = name.substr(i, 1);
    if (b.upper() == b && b.lower() != b && a.lower() == a && a.upper() != a) { return name.substr(0, i).lower(); }
    i = i + 1;
  }
  return name.lower();
};

known_has = (known, s){
  i = 0;
  while (i < known.size) {
    if (known[i] == s) { return 1; }
    i = i + 1;
  }
  return 0;
};

known_add = (known, s){
  if (len(s) == 0) { return; }
  if (known_has(known, s) == 0) { known.push(s.copy()); }
};

mod_inc = (mods, m){
  i = 0;
  while (i < mods.size) {
    if (mods[i].k == m) {
      mods[i].v = mods[i].v + 1;
      return;
    }
    i = i + 1;
  }
  mods.push({k = m.copy(), v = 1});
};

parse_param = (txt, idx){
  p = collapse_ws(txt);
  if (len(p) == 0 || p == "void") { return {skip = 1}; }
  if (p == "...") { return {skip = 0, type = "...", nm = "", decl = "...", vararg = 1, callback = 0, ptr = 0, arr = 0}; }

  if (find_from(p, "(*", 0) >= 0) {
    pos = find_from(p, "(*", 0);
    end = find_from(p, ")", pos + 2);
    pn = "p" + idx;
    if (end > pos + 2) { pn = p.substr(pos + 2, end - pos - 2).trim(); }
    return {skip = 0, type = p.copy(), nm = pn.copy(), decl = p.copy(), vararg = 0, callback = 1, ptr = 1, arr = 0};
  }

  ws = split_words(p);
  if (ws.size == 1) {
    t = ws[0];
    ptrf = 0;
    arrf = 0;
    if (find_from(t, "*", 0) >= 0) { ptrf = 1; }
    if (find_from(t, "[", 0) >= 0) { arrf = 1; }
    return {skip = 0, type = t.copy(), nm = ("p" + idx).copy(), decl = (t + " p" + idx).copy(), vararg = 0, callback = 0,
            ptr = ptrf, arr = arrf};
  }

  last = ws[ws.size - 1];
  name = last;
  arr_suf = "";
  ap = find_from(last, "[", 0);
  if (ap >= 0) {
    name = last.substr(0, ap);
    arr_suf = last.substr(ap, len(last) - ap);
  }
  stars = 0;
  while (len(name) > 0 && name.substr(0, 1) == "*") {
    stars = stars + 1;
    name = name.substr(1, len(name) - 1);
  }
  if (len(name) == 0) { name = "p" + idx; }

  parts = {};
  i = 0;
  while (i < ws.size - 1) { parts.push(ws[i].copy()); i = i + 1; }
  t = join(parts, " ");
  if (stars > 0) {
    i = 0;
    while (i < stars) { t = t + "*"; i = i + 1; }
  }
  if (len(arr_suf) > 0) { t = t + " " + arr_suf; }
  t = collapse_ws(t);

  ptr2 = 0;
  arr2 = 0;
  if (find_from(t, "*", 0) >= 0) { ptr2 = 1; }
  if (len(arr_suf) > 0) { arr2 = 1; }
  return {skip = 0, type = t.copy(), nm = name.copy(), decl = p.copy(), vararg = 0, callback = 0,
          ptr = ptr2, arr = arr2};
};

parse_proto = (line){
  s = collapse_ws(line);
  if (!s.endsWith(";")) { return {ok = 0, reason = "no_semicolon"}; }
  s = s.substr(0, len(s) - 1).trim();
  if (s.startsWith("typedef ")) { return {ok = 0, reason = "typedef"}; }

  op = find_from(s, "(", 0);
  if (op < 0) { return {ok = 0, reason = "no_open"}; }

  i = op;
  d = 0;
  cp = -1;
  while (i < len(s)) {
    ch = s.substr(i, 1);
    if (ch == "(") { d = d + 1; }
    else if (ch == ")") {
      d = d - 1;
      if (d == 0) { cp = i; break; }
    }
    i = i + 1;
  }
  if (cp < 0) { return {ok = 0, reason = "unbalanced"}; }

  left = s.substr(0, op).trim();
  right = s.substr(cp + 1, len(s) - cp - 1).trim();
  if (len(right) > 0) { return {ok = 0, reason = "trailing"}; }

  ws = split_words(left);
  if (ws.size < 2) { return {ok = 0, reason = "left_short"}; }
  name = ws[ws.size - 1];
  stars = 0;
  while (len(name) > 0 && name.substr(0, 1) == "*") { name = name.substr(1, len(name) - 1); stars = stars + 1; }
  if (len(name) == 0) { return {ok = 0, reason = "name_missing"}; }

  rt_parts = {};
  i = 0;
  while (i < ws.size - 1) {
    w = ws[i];
    if (w != "RLAPI" && w != "extern") { rt_parts.push(w.copy()); }
    i = i + 1;
  }
  rt = join(rt_parts, " ");
  i = 0;
  while (i < stars) { rt = rt + "*"; i = i + 1; }
  rt = collapse_ws(rt);

  params_txt = s.substr(op + 1, cp - op - 1).trim();
  params = {};
  if (len(params_txt) > 0 && params_txt != "void") {
    rawp = split_top(params_txt, ",");
    i = 0;
    while (i < rawp.size) {
      p = parse_param(rawp[i], i);
      if (p.skip == 0) { params.push(p); }
      i = i + 1;
    }
  }

  return {ok = 1, fn = name.copy(), rt = rt.copy(), ps = params, raw = s.copy()};
};

classify = (f, known){
  hp = 0;
  hs = has_named_type(f.return_type, known);
  hv = 0;
  hc = 0;
  prim = is_primitive(f.return_type);

  i = 0;
  while (i < f.params.size) {
    p = f.params[i];
    if (p.vararg == 1) { hv = 1; }
    if (p.callback == 1) { hc = 1; }
    if (p.arr == 1) { hp = 1; }
    if (p.ptr == 1 && !is_char_ptr(p.type)) { hp = 1; }
    if (has_named_type(p.type, known)) { hs = 1; }
    if (!is_primitive(p.type)) { prim = 0; }
    i = i + 1;
  }

  if (hv == 1 || hc == 1) { return {class = "D", hv = hv, hc = hc}; }
  if (hp == 1) { return {class = "C", hv = hv, hc = hc}; }
  if (hs == 1 || prim == 0) { return {class = "B", hv = hv, hc = hc}; }
  return {class = "A", hv = hv, hc = hc};
};

emit_param_decl = (ps){
  if (ps.size == 0) { return "void"; }
  out = {};
  i = 0;
  while (i < ps.size) { out.push(ps[i].decl.copy()); i = i + 1; }
  return join(out, ", ");
};

ffi_type = (t, known){
  k = collapse_ws(t).lower().replaceAll(" ", "");
  while (k.startsWith("const")) { k = k.substr(5, len(k) - 5); }
  if (k == "void") { return {m = "void", todo = 0}; }
  if (find_from(k, "*", 0) >= 0) {
    if (is_char_ptr(k)) { return {m = "char*", todo = 0}; }
    return {m = "void*", todo = 0};
  }
  if (k == "float" || k == "double") { return {m = "f32", todo = 0}; }
  if (k == "bool" || find_from(k, "int", 0) >= 0 || find_from(k, "long", 0) >= 0 || k == "size_t" || k == "short" || k == "char") {
    return {m = "i32", todo = 0};
  }
  if (has_named_type(t, known)) { return {m = "void*", todo = 1}; }
  return {m = "void*", todo = 1};
};

// ---------------- main ----------------
rawb = read("./raylib/src/raylib.h");
if (rawb == null) { println("error: cannot read raylib header"); return; }
raw = rawb.string;
lines = raw.split("\n");

known = {};
defines = {};
enums = {};
structs = {};
functions = {};
skipped = {};

in_block = 0;
mode = "";
acc = "";
proto = "";

i = 0;
while (i < lines.size) {
  line = sstr(lines[i]);

  // remove block comments (line-based)
  cleaned = "";
  pos = 0;
  while (pos < len(line)) {
    if (in_block == 1) {
      e = find_from(line, "*/", pos);
      if (e < 0) { pos = len(line); continue; }
      in_block = 0;
      pos = e + 2;
      continue;
    }

    b = find_from(line, "/*", pos);
    if (b < 0) {
      cleaned = cleaned + line.substr(pos, len(line) - pos);
      pos = len(line);
    } else {
      cleaned = cleaned + line.substr(pos, b - pos);
      e = find_from(line, "*/", b + 2);
      if (e < 0) { in_block = 1; pos = len(line); }
      else { pos = e + 2; }
    }
  }

  sl = cleaned;
  cpos = find_from(sl, "//", 0);
  if (cpos >= 0) { sl = sl.substr(0, cpos); }
  t = sl.trim();
  if (len(t) == 0) { i = i + 1; continue; }

  if (t.startsWith("#define ")) {
    full = t;
    while (full.endsWith("\\") && i + 1 < lines.size) {
      full = full.substr(0, len(full) - 1).trim() + " " + sstr(lines[i + 1]).trim();
      i = i + 1;
    }
    rest = full.substr(8, len(full) - 8).trim();
    ws = split_words(rest);
    if (ws.size >= 1) {
      name = ws[0].copy();
      val = "";
      if (ws.size > 1) {
        vv = {};
        j = 1;
        while (j < ws.size) { vv.push(ws[j].copy()); j = j + 1; }
        val = join(vv, " ");
      }
      defines.push({dn = name.copy(), dv = val.copy()});
    }
    i = i + 1;
    continue;
  }

  if (t.startsWith("#")) { i = i + 1; continue; }

  // enum collection
  if (mode == "enum") {
    acc = acc + " " + t;
    if (find_from(t, "};", 0) >= 0 || t.endsWith(";")) {
      ob = find_from(acc, "{", 0);
      cb = find_from(acc, "}", ob + 1);
      if (ob >= 0 && cb > ob) {
        tail = acc.substr(cb + 1, len(acc) - cb - 1).replaceAll(";", "").trim();
        ename = tail;
        if (len(ename) == 0) { ename = "AnonymousEnum" + enums.size; }

        body = acc.substr(ob + 1, cb - ob - 1);
        ents = split_top(body, ",");
        en_items = {};
        j = 0;
        while (j < ents.size) {
          e = ents[j].trim();
          if (len(e) == 0) { j = j + 1; continue; }
          eq = find_from(e, "=", 0);
          if (eq >= 0) {
            n = e.substr(0, eq).trim();
            v = e.substr(eq + 1, len(e) - eq - 1).trim();
            if (len(n) > 0) { en_items.push({id = n.copy(), iv = v.copy()}); }
          } else {
            en_items.push({id = e.copy(), iv = "".copy()});
          }
          j = j + 1;
        }

        enums.push({en = ename.copy(), items = en_items});
        known_add(known, ename.copy());
      } else {
        skipped.push({kind = "enum", reason = "bad_block", text = acc.copy()});
      }
      mode = "";
      acc = "";
    }
    i = i + 1;
    continue;
  }

  // struct collection
  if (mode == "struct") {
    acc = acc + " " + t;
    if (find_from(t, "};", 0) >= 0 || t.endsWith(";")) {
      ob = find_from(acc, "{", 0);
      cb = find_from(acc, "}", ob + 1);
      if (ob >= 0 && cb > ob) {
        pre = acc.substr(0, ob).trim();
        tag = pre.substr(len("typedef struct"), len(pre) - len("typedef struct")).trim();
        tail = acc.substr(cb + 1, len(acc) - cb - 1).replaceAll(";", "").trim();
        fields = acc.substr(ob + 1, cb - ob - 1).trim();
        if (len(tail) > 0) {
          structs.push({sn = tail.copy(), st = tag.copy(), sf = fields.copy()});
          known_add(known, tail.copy());
        } else {
          skipped.push({kind = "typedef_struct", reason = "missing_name", text = acc.copy()});
        }
      } else {
        // forward declaration: typedef struct X Y;
        ws = split_words(acc.replaceAll(";", ""));
        if (ws.size >= 3) {
          alias = ws[ws.size - 1];
          known_add(known, alias.copy());
        } else {
          skipped.push({kind = "typedef_struct", reason = "bad_block", text = acc.copy()});
        }
      }
      mode = "";
      acc = "";
    }
    i = i + 1;
    continue;
  }

  if (t.startsWith("typedef enum")) {
    mode = "enum";
    acc = t.copy();
    if (find_from(t, "}", 0) >= 0 && t.endsWith(";")) {
      // let next loop pass handle close uniformly
    }
    i = i + 1;
    continue;
  }

  if (t.startsWith("typedef struct")) {
    mode = "struct";
    acc = t.copy();
    i = i + 1;
    continue;
  }

  if (t.startsWith("typedef ")) {
    ws = split_words(t.replaceAll(";", ""));
    if (ws.size >= 3 && find_from(t, "(", 0) < 0 && find_from(t, "{", 0) < 0) {
      known_add(known, ws[ws.size - 1].copy());
    }
    i = i + 1;
    continue;
  }

  // function prototype accumulation
  if (len(proto) == 0) {
    if (find_from(t, "(", 0) >= 0 && !t.startsWith("if ") && !t.startsWith("for ") && !t.startsWith("while ")) {
      proto = t.copy();
    }
  } else {
    proto = proto + " " + t;
  }

  if (len(proto) > 0 && find_from(proto, ";", 0) >= 0) {
    semi = find_from(proto, ";", 0);
    cand = proto.substr(0, semi + 1).trim();
    parsed = parse_proto(cand);
    if (parsed.ok == 1) {
      cc = classify({return_type = parsed.rt, params = parsed.ps}, known);
      functions.push({
        fn = parsed.fn.copy(),
        rt = parsed.rt.copy(),
        ps = parsed.ps,
        raw = parsed.raw.copy(),
        cls = cc.class.copy(),
        hv = cc.hv,
        hc = cc.hc,
        mod = module_of(parsed.fn).copy()
      });
    } else {
      skipped.push({kind = "function", reason = parsed.reason.copy(), text = cand.copy()});
    }
    if (semi + 1 < len(proto)) { proto = proto.substr(semi + 1, len(proto) - semi - 1).trim(); }
    else { proto = ""; }
  }

  i = i + 1;
}

if (len(proto) > 0) { skipped.push({kind = "function", reason = "unterminated", text = proto.copy()}); }

// stats
stats = {total_functions = functions.size, total_enums = enums.size, total_defines = defines.size, total_typedef_structs = structs.size,
         class_a = 0, class_b = 0, class_c = 0, class_d = 0};
mods = {};
i = 0;
while (i < functions.size) {
  f = functions[i];
  if (f.cls == "A") { stats.class_a = stats.class_a + 1; }
  else if (f.cls == "B") { stats.class_b = stats.class_b + 1; }
  else if (f.cls == "C") { stats.class_c = stats.class_c + 1; }
  else if (f.cls == "D") { stats.class_d = stats.class_d + 1; }
  mod_inc(mods, f.mod);
  i = i + 1;
}

// inventory json
j = "{\n";
j = j + "  \"functions\": [\n";
i = 0;
while (i < functions.size) {
  f = functions[i];
  if (i > 0) { j = j + ",\n"; }
  cb = "false";
  hv = "false";
  if (f.hc == 1) { cb = "true"; }
  if (f.hv == 1) { hv = "true"; }
  j = j + "    {\n";
  j = j + "      \"name\": " + jq(f.fn) + ",\n";
  j = j + "      \"return_type\": " + jq(f.rt) + ",\n";
  j = j + "      \"class\": " + jq(f.cls) + ",\n";
  j = j + "      \"module\": " + jq(f.mod) + ",\n";
  j = j + "      \"has_callback\": " + cb + ",\n";
  j = j + "      \"has_vararg\": " + hv + ",\n";
  j = j + "      \"params\": [";
  p = 0;
  while (p < f.ps.size) {
    x = f.ps[p];
    if (p > 0) { j = j + ", "; }
    j = j + "{\"type_string\": " + jq(x.type) + ", \"name_string\": " + jq(x.nm) + ", \"decl\": " + jq(x.decl) + "}";
    p = p + 1;
  }
  j = j + "],\n";
  j = j + "      \"signature\": " + jq(f.raw) + "\n";
  j = j + "    }";
  i = i + 1;
}
j = j + "\n  ],\n";

j = j + "  \"enums\": [\n";
i = 0;
while (i < enums.size) {
  e = enums[i];
  if (i > 0) { j = j + ",\n"; }
  j = j + "    {\"name\": " + jq(e.en) + ", \"enumerators\": [";
  k = 0;
  while (k < e.enumerators.size) {
    it = e.items[k];
    if (k > 0) { j = j + ", "; }
    j = j + "{\"name\": " + jq(it.id);
    if (len(it.iv) > 0) { j = j + ", \"value\": " + jq(it.iv); }
    j = j + "}";
    k = k + 1;
  }
  j = j + "]}";
  i = i + 1;
}
j = j + "\n  ],\n";

j = j + "  \"defines\": [\n";
i = 0;
while (i < defines.size) {
  d = defines[i];
  if (i > 0) { j = j + ",\n"; }
  j = j + "    {\"name\": " + jq(d.dn) + ", \"value\": " + jq(d.dv) + "}";
  i = i + 1;
}
j = j + "\n  ],\n";

j = j + "  \"typedef_structs\": [\n";
i = 0;
while (i < structs.size) {
  s = structs[i];
  if (i > 0) { j = j + ",\n"; }
  j = j + "    {\"name\": " + jq(s.sn) + ", \"tag\": " + jq(s.st) + ", \"fields_text\": " + jq(s.sf) + "}";
  i = i + 1;
}
j = j + "\n  ],\n";

j = j + "  \"skipped\": [\n";
i = 0;
while (i < skipped.size) {
  s = skipped[i];
  if (i > 0) { j = j + ",\n"; }
  j = j + "    {\"kind\": " + jq(s.kind) + ", \"reason\": " + jq(s.reason) + ", \"text\": " + jq(s.text) + "}";
  i = i + 1;
}
j = j + "\n  ],\n";

j = j + "  \"stats\": {\n";
j = j + "    \"total_functions\": " + stats.total_functions + ",\n";
j = j + "    \"total_enums\": " + stats.total_enums + ",\n";
j = j + "    \"total_defines\": " + stats.total_defines + ",\n";
j = j + "    \"total_typedef_structs\": " + stats.total_typedef_structs + ",\n";
j = j + "    \"total_skipped\": " + skipped.size + ",\n";
j = j + "    \"by_complexity\": {\"A\": " + stats.class_a + ", \"B\": " + stats.class_b + ", \"C\": " + stats.class_c + ", \"D\": " + stats.class_d + "},\n";
j = j + "    \"by_module\": {";
i = 0;
while (i < mods.size) {
  if (i > 0) { j = j + ", "; }
  m = mods[i];
  j = j + jq(m.k) + ": " + m.v;
  i = i + 1;
}
j = j + "}\n";
j = j + "  }\n";
j = j + "}\n";
write("./tools/raylib_inventory.json", j);

// shim header
h = "#ifndef GENERATED_RAYLIB_SHIM_H\n#define GENERATED_RAYLIB_SHIM_H\n\n#include <stddef.h>\n#include <stdint.h>\n#include \"../raylib/src/raylib.h\"\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n";
i = 0;
while (i < functions.size) {
  f = functions[i];
  if (f.cls != "A") { h = h + "// TODO(" + f.cls + "): complex signature may need flattening\n"; }
  h = h + f.rt + " rl_" + f.fn + "(" + emit_param_decl(f.ps) + ");\n";
  i = i + 1;
}
h = h + "\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n";
write("./generated/raylib_shim.h", h);

// shim c
c = "#include \"raylib_shim.h\"\n\n";
i = 0;
while (i < functions.size) {
  f = functions[i];
  c = c + f.rt + " rl_" + f.fn + "(" + emit_param_decl(f.ps) + ")\n{\n";
  c = c + "    // TODO: implement wrapper for " + f.fn + "\n";
  p = 0;
  while (p < f.ps.size) {
    x = f.ps[p];
    if (len(x.nm) > 0 && x.vararg == 0) { c = c + "    (void)" + x.nm + ";\n"; }
    p = p + 1;
  }
  if (f.rt == "void") { c = c + "    return;\n"; }
  else if (find_from(f.rt, "*", 0) >= 0) { c = c + "    return NULL;\n"; }
  else { c = c + "    " + f.rt + " _ret = {0};\n    return _ret;\n"; }
  c = c + "}\n\n";
  i = i + 1;
}
write("./generated/raylib_shim.c", c);

// ffi disturb
fd = "// Auto-generated by tools/raylib_gen.dist\n";
fd = fd + "// Mapping: int/bool->i32, float/double->f32, char*->char*, other ptr/struct->void*\n";
fd = fd + "shim_path = \"./libraylib_disturb.so\";\nraylib_shim = ffi.load(shim_path,\n";
ffi_lines = {};
ffi_todos = {};
ffi_skipped = {};
i = 0;
while (i < functions.size) {
  f = functions[i];
  if (f.cls == "D") { ffi_skipped.push(f); i = i + 1; continue; }
  rm = ffi_type(f.rt, known);
  if (rm.todo == 1) { ffi_todos.push(("return " + f.fn + ": " + f.rt).copy()); }
  ps = {};
  p = 0;
  while (p < f.ps.size) {
    x = f.ps[p];
    if (x.vararg == 1) { break; }
    pm = ffi_type(x.type, known);
    if (pm.todo == 1) { ffi_todos.push(("param " + f.fn + ": " + x.type).copy()); }
    ps.push(pm.m.copy());
    p = p + 1;
  }
  ffi_lines.push((rm.m + " rl_" + f.fn + "(" + join(ps, ", ") + ")").copy());
  i = i + 1;
}
i = 0;
while (i < ffi_lines.size) {
  comma = "";
  if (i < ffi_lines.size - 1) { comma = ","; }
  fd = fd + "  \"" + ffi_lines[i] + "\"" + comma + "\n";
  i = i + 1;
}
fd = fd + ");\n\n";
if (ffi_skipped.size > 0) {
  fd = fd + "// TODO: class D callbacks/varargs\n";
  i = 0;
  while (i < ffi_skipped.size) { fd = fd + "// - rl_" + ffi_skipped[i].fn + ": " + ffi_skipped[i].raw + "\n"; i = i + 1; }
  fd = fd + "\n";
}
if (ffi_todos.size > 0) {
  fd = fd + "// TODO: unknown mappings\n";
  i = 0;
  while (i < ffi_todos.size) { fd = fd + "// - " + ffi_todos[i] + "\n"; i = i + 1; }
}
write("./generated/raylib_ffi.dist", fd);

// report
rep = "# Raylib Header Inventory Report\n\n";
rep = rep + "Generated by `tools/raylib_gen.dist`.\n\n";
rep = rep + "## Totals\n\n";
rep = rep + "- Total functions: " + functions.size + "\n";
rep = rep + "- Class A: " + stats.class_a + "\n";
rep = rep + "- Class B: " + stats.class_b + "\n";
rep = rep + "- Class C: " + stats.class_c + "\n";
rep = rep + "- Class D: " + stats.class_d + "\n";
rep = rep + "- Enums: " + enums.size + "\n";
rep = rep + "- Defines: " + defines.size + "\n";
rep = rep + "- Typedef structs: " + structs.size + "\n";
rep = rep + "- Skipped parse entries: " + skipped.size + "\n\n";

hard = {};
i = 0; while (i < functions.size) { if (functions[i].cls == "D") { hard.push(functions[i]); } i = i + 1; }
i = 0; while (i < functions.size) { if (functions[i].cls == "C") { hard.push(functions[i]); } i = i + 1; }
i = 0; while (i < functions.size) { if (functions[i].cls == "B") { hard.push(functions[i]); } i = i + 1; }

rep = rep + "## Top 20 Hardest Functions\n\n";
if (hard.size == 0) { rep = rep + "- (none)\n\n"; }
else {
  lim = 20;
  if (hard.size < 20) { lim = hard.size; }
  i = 0; while (i < lim) { rep = rep + "- [" + hard[i].cls + "] " + hard[i].fn + " :: `" + hard[i].raw + "`\n"; i = i + 1; }
  rep = rep + "\n";
}

rep = rep + "## Callbacks / Varargs\n\n";
found = 0;
i = 0;
while (i < functions.size) {
  f = functions[i];
  if (f.hc == 1 || f.hv == 1) {
    found = 1;
    tag = "";
    if (f.hc == 1) { tag = "callback"; }
    if (f.hv == 1) {
      if (len(tag) > 0) { tag = tag + ", varargs"; }
      else { tag = "varargs"; }
    }
    rep = rep + "- " + f.fn + " (" + tag + ") :: `" + f.raw + "`\n";
  }
  i = i + 1;
}
if (found == 0) { rep = rep + "- (none)\n"; }
rep = rep + "\n## Skipped Entries\n\n";
if (skipped.size == 0) { rep = rep + "- (none)\n"; }
else {
  i = 0;
  while (i < skipped.size) {
    s = skipped[i];
    rep = rep + "- [" + s.kind + "] " + s.reason + " :: `" + s.text + "`\n";
    i = i + 1;
  }
}
write("./generated/report.md", rep);

println("raylib_gen: functions=" + functions.size + " enums=" + enums.size + " defines=" + defines.size + " structs=" + structs.size + " skipped=" + skipped.size);

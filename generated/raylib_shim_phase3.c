// Auto-generated by tools/raylib_phase3.py from generated/plan.json
#include <stdlib.h>
#include <stdint.h>
#include <string.h>
#include "raylib.h"
#include "raylib_shim_phase3.h"

typedef intptr_t rl_disturb_int_t;
#if INTPTR_MAX == INT64_MAX
typedef double rl_disturb_float_t;
#else
typedef float rl_disturb_float_t;
#endif

static inline Color rl_color_from_rgba_i32(int32_t rgba) {
    Color c;
    c.r = (uint8_t)((rgba >> 24) & 0xFF);
    c.g = (uint8_t)((rgba >> 16) & 0xFF);
    c.b = (uint8_t)((rgba >> 8) & 0xFF);
    c.a = (uint8_t)(rgba & 0xFF);
    return c;
}

static inline int32_t rl_rgba_i32_from_color(Color c) {
    return ((int32_t)c.r << 24) | ((int32_t)c.g << 16) | ((int32_t)c.b << 8) | (int32_t)c.a;
}

void* rl2_BeginBlendMode(int32_t mode) {
    BeginBlendMode((int)mode);
    return NULL;
}

void* rl2_BeginDrawing(void) {
    BeginDrawing();
    return NULL;
}

void* rl2_BeginMode2D(void* camera) {
    Camera2D camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera2D*)camera);
    }
    BeginMode2D(camera_value);
    return NULL;
}

void* rl2_BeginMode3D(void* camera) {
    Camera3D camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera3D*)camera);
    }
    BeginMode3D(camera_value);
    return NULL;
}

void* rl2_BeginScissorMode(int32_t x, int32_t y, int32_t width, int32_t height) {
    BeginScissorMode((int)x, (int)y, (int)width, (int)height);
    return NULL;
}

void* rl2_BeginShaderMode(void* shader) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    BeginShaderMode(shader_value);
    return NULL;
}

void* rl2_BeginTextureMode(void* target) {
    RenderTexture2D target_value;
    memset(&target_value, 0, sizeof(target_value));
    if (target != NULL) {
        target_value = *((RenderTexture2D*)target);
    }
    BeginTextureMode(target_value);
    return NULL;
}

void* rl2_BeginVrStereoMode(void* config) {
    VrStereoConfig config_value;
    memset(&config_value, 0, sizeof(config_value));
    if (config != NULL) {
        config_value = *((VrStereoConfig*)config);
    }
    BeginVrStereoMode(config_value);
    return NULL;
}

int32_t rl2_ChangeDirectory(char* dirPath) {
    return ChangeDirectory((const char*)dirPath) ? 1 : 0;
}

int32_t rl2_CheckCollisionBoxSphere(float* box, int32_t box_len, float center_x, float center_y, float center_z, float radius) {
    if (box_len < 6) return 0;
    if (box == NULL) return 0;
    rl_disturb_float_t* box_src = (rl_disturb_float_t*)(void*)box;
    BoundingBox box_value;
    memset(&box_value, 0, sizeof(box_value));
    box_value.min.x = (float)box_src[0];
    box_value.min.y = (float)box_src[1];
    box_value.min.z = (float)box_src[2];
    box_value.max.x = (float)box_src[3];
    box_value.max.y = (float)box_src[4];
    box_value.max.z = (float)box_src[5];
    Vector3 center = { center_x, center_y, center_z };
    return CheckCollisionBoxSphere(box_value, center, (float)radius) ? 1 : 0;
}

int32_t rl2_CheckCollisionBoxes(float* box1, int32_t box1_len, float* box2, int32_t box2_len) {
    if (box1_len < 6) return 0;
    if (box1 == NULL) return 0;
    rl_disturb_float_t* box1_src = (rl_disturb_float_t*)(void*)box1;
    BoundingBox box1_value;
    memset(&box1_value, 0, sizeof(box1_value));
    box1_value.min.x = (float)box1_src[0];
    box1_value.min.y = (float)box1_src[1];
    box1_value.min.z = (float)box1_src[2];
    box1_value.max.x = (float)box1_src[3];
    box1_value.max.y = (float)box1_src[4];
    box1_value.max.z = (float)box1_src[5];
    if (box2_len < 6) return 0;
    if (box2 == NULL) return 0;
    rl_disturb_float_t* box2_src = (rl_disturb_float_t*)(void*)box2;
    BoundingBox box2_value;
    memset(&box2_value, 0, sizeof(box2_value));
    box2_value.min.x = (float)box2_src[0];
    box2_value.min.y = (float)box2_src[1];
    box2_value.min.z = (float)box2_src[2];
    box2_value.max.x = (float)box2_src[3];
    box2_value.max.y = (float)box2_src[4];
    box2_value.max.z = (float)box2_src[5];
    return CheckCollisionBoxes(box1_value, box2_value) ? 1 : 0;
}

int32_t rl2_CheckCollisionCircleLine(float center_x, float center_y, float radius, float p1_x, float p1_y, float p2_x, float p2_y) {
    Vector2 center = { center_x, center_y };
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    return CheckCollisionCircleLine(center, (float)radius, p1, p2) ? 1 : 0;
}

int32_t rl2_CheckCollisionCircleRec(float center_x, float center_y, float radius, float rec_x, float rec_y, float rec_w, float rec_h) {
    Vector2 center = { center_x, center_y };
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    return CheckCollisionCircleRec(center, (float)radius, rec) ? 1 : 0;
}

int32_t rl2_CheckCollisionCircles(float center1_x, float center1_y, float radius1, float center2_x, float center2_y, float radius2) {
    Vector2 center1 = { center1_x, center1_y };
    Vector2 center2 = { center2_x, center2_y };
    return CheckCollisionCircles(center1, (float)radius1, center2, (float)radius2) ? 1 : 0;
}

int32_t rl2_CheckCollisionLines(float startPos1_x, float startPos1_y, float endPos1_x, float endPos1_y, float startPos2_x, float startPos2_y, float endPos2_x, float endPos2_y, float* collisionPoint, int32_t collisionPoint_len) {
    Vector2 startPos1 = { startPos1_x, startPos1_y };
    Vector2 endPos1 = { endPos1_x, endPos1_y };
    Vector2 startPos2 = { startPos2_x, startPos2_y };
    Vector2 endPos2 = { endPos2_x, endPos2_y };
    if (collisionPoint_len < 2) return 0;
    if (collisionPoint == NULL) return 0;
    return CheckCollisionLines(startPos1, endPos1, startPos2, endPos2, (Vector2*)collisionPoint) ? 1 : 0;
}

int32_t rl2_CheckCollisionPointCircle(float point_x, float point_y, float center_x, float center_y, float radius) {
    Vector2 point = { point_x, point_y };
    Vector2 center = { center_x, center_y };
    return CheckCollisionPointCircle(point, center, (float)radius) ? 1 : 0;
}

int32_t rl2_CheckCollisionPointLine(float point_x, float point_y, float p1_x, float p1_y, float p2_x, float p2_y, int32_t threshold) {
    Vector2 point = { point_x, point_y };
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    return CheckCollisionPointLine(point, p1, p2, (int)threshold) ? 1 : 0;
}

int32_t rl2_CheckCollisionPointPoly(float point_x, float point_y, float* points, int32_t pointCount) {
    Vector2 point = { point_x, point_y };
    if (pointCount < 0) return 0;
    if (pointCount > 0 && points == NULL) return 0;
    return CheckCollisionPointPoly(point, (const Vector2*)points, (int)pointCount) ? 1 : 0;
}

int32_t rl2_CheckCollisionPointRec(float point_x, float point_y, float rec_x, float rec_y, float rec_w, float rec_h) {
    Vector2 point = { point_x, point_y };
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    return CheckCollisionPointRec(point, rec) ? 1 : 0;
}

int32_t rl2_CheckCollisionPointTriangle(float point_x, float point_y, float p1_x, float p1_y, float p2_x, float p2_y, float p3_x, float p3_y) {
    Vector2 point = { point_x, point_y };
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Vector2 p3 = { p3_x, p3_y };
    return CheckCollisionPointTriangle(point, p1, p2, p3) ? 1 : 0;
}

int32_t rl2_CheckCollisionRecs(float rec1_x, float rec1_y, float rec1_w, float rec1_h, float rec2_x, float rec2_y, float rec2_w, float rec2_h) {
    Rectangle rec1 = { rec1_x, rec1_y, rec1_w, rec1_h };
    Rectangle rec2 = { rec2_x, rec2_y, rec2_w, rec2_h };
    return CheckCollisionRecs(rec1, rec2) ? 1 : 0;
}

int32_t rl2_CheckCollisionSpheres(float center1_x, float center1_y, float center1_z, float radius1, float center2_x, float center2_y, float center2_z, float radius2) {
    Vector3 center1 = { center1_x, center1_y, center1_z };
    Vector3 center2 = { center2_x, center2_y, center2_z };
    return CheckCollisionSpheres(center1, (float)radius1, center2, (float)radius2) ? 1 : 0;
}

void* rl2_ClearBackground(int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ClearBackground(color);
    return NULL;
}

void* rl2_ClearWindowState(int32_t flags) {
    ClearWindowState((unsigned int)flags);
    return NULL;
}

void* rl2_CloseAudioDevice(void) {
    CloseAudioDevice();
    return NULL;
}

void* rl2_CloseWindow(void) {
    CloseWindow();
    return NULL;
}

char* rl2_CodepointToUTF8(int32_t codepoint, int32_t* utf8Size, int32_t utf8Size_len) {
    if (utf8Size_len < 1) return NULL;
    if (utf8Size == NULL) return NULL;
    return (char*)CodepointToUTF8((int)codepoint, (int*)utf8Size);
}

int32_t rl2_ColorAlpha(int32_t color_rgba, float alpha, int32_t* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorAlpha(color, (float)alpha);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorAlphaBlend(int32_t dst_rgba, int32_t src_rgba, int32_t tint_rgba, int32_t* ret_out, int32_t ret_out_len) {
    Color dst = rl_color_from_rgba_i32(dst_rgba);
    Color src = rl_color_from_rgba_i32(src_rgba);
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorAlphaBlend(dst, src, tint);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorBrightness(int32_t color_rgba, float factor, int32_t* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorBrightness(color, (float)factor);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorContrast(int32_t color_rgba, float contrast, int32_t* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorContrast(color, (float)contrast);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorFromHSV(float hue, float saturation, float value, int32_t* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorFromHSV((float)hue, (float)saturation, (float)value);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorFromNormalized(float normalized_x, float normalized_y, float normalized_z, float normalized_w, int32_t* ret_out, int32_t ret_out_len) {
    Vector4 normalized = { normalized_x, normalized_y, normalized_z, normalized_w };
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorFromNormalized(normalized);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorIsEqual(int32_t col1_rgba, int32_t col2_rgba) {
    Color col1 = rl_color_from_rgba_i32(col1_rgba);
    Color col2 = rl_color_from_rgba_i32(col2_rgba);
    return ColorIsEqual(col1, col2) ? 1 : 0;
}

int32_t rl2_ColorLerp(int32_t color1_rgba, int32_t color2_rgba, float factor, int32_t* ret_out, int32_t ret_out_len) {
    Color color1 = rl_color_from_rgba_i32(color1_rgba);
    Color color2 = rl_color_from_rgba_i32(color2_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorLerp(color1, color2, (float)factor);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorNormalize(int32_t color_rgba, float* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 4) return 0;
    if (ret_out == NULL) return 0;
    Vector4 rl_value = ColorNormalize(color);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.z;
    rl_out[3] = (rl_disturb_float_t)rl_value.w;
    return 1;
}

int32_t rl2_ColorTint(int32_t color_rgba, int32_t tint_rgba, int32_t* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = ColorTint(color, tint);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_ColorToHSV(int32_t color_rgba, float* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 3) return 0;
    if (ret_out == NULL) return 0;
    Vector3 rl_value = ColorToHSV(color);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.z;
    return 1;
}

int32_t rl2_ColorToInt(int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    return (int32_t)ColorToInt(color);
}

void* rl2_CompressData(int32_t* data, int32_t dataSize, int32_t* compDataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    return (void*)CompressData((const unsigned char*)data, (int)dataSize, (int*)compDataSize);
}

int32_t rl2_ComputeCRC32(int32_t* data, int32_t dataSize) {
    if (dataSize < 0) return 0;
    if (dataSize > 0 && data == NULL) return 0;
    return (int32_t)ComputeCRC32((unsigned char*)data, (int)dataSize);
}

void* rl2_ComputeMD5(int32_t* data, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    return (void*)ComputeMD5((unsigned char*)data, (int)dataSize);
}

void* rl2_ComputeSHA1(int32_t* data, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    return (void*)ComputeSHA1((unsigned char*)data, (int)dataSize);
}

void* rl2_ComputeSHA256(int32_t* data, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    return (void*)ComputeSHA256((unsigned char*)data, (int)dataSize);
}

void* rl2_DecodeDataBase64(char* text, int32_t* outputSize, int32_t outputSize_len) {
    if (outputSize_len < 1) return NULL;
    if (outputSize == NULL) return NULL;
    return (void*)DecodeDataBase64((const char*)text, (int*)outputSize);
}

void* rl2_DecompressData(int32_t* compData, int32_t compDataSize, int32_t* dataSize) {
    if (compDataSize < 0) return NULL;
    if (compDataSize > 0 && compData == NULL) return NULL;
    return (void*)DecompressData((const unsigned char*)compData, (int)compDataSize, (int*)dataSize);
}

int32_t rl2_DirectoryExists(char* dirPath) {
    return DirectoryExists((const char*)dirPath) ? 1 : 0;
}

void* rl2_DisableCursor(void) {
    DisableCursor();
    return NULL;
}

void* rl2_DisableEventWaiting(void) {
    DisableEventWaiting();
    return NULL;
}

void* rl2_DrawBillboard(void* camera, void* texture, float position_x, float position_y, float position_z, float scale, int32_t tint_rgba) {
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Vector3 position = { position_x, position_y, position_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawBillboard(camera_value, texture_value, position, (float)scale, tint);
    return NULL;
}

void* rl2_DrawBillboardPro(void* camera, void* texture, float source_x, float source_y, float source_w, float source_h, float position_x, float position_y, float position_z, float up_x, float up_y, float up_z, float size_x, float size_y, float origin_x, float origin_y, float rotation, int32_t tint_rgba) {
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle source = { source_x, source_y, source_w, source_h };
    Vector3 position = { position_x, position_y, position_z };
    Vector3 up = { up_x, up_y, up_z };
    Vector2 size = { size_x, size_y };
    Vector2 origin = { origin_x, origin_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawBillboardPro(camera_value, texture_value, source, position, up, size, origin, (float)rotation, tint);
    return NULL;
}

void* rl2_DrawBillboardRec(void* camera, void* texture, float source_x, float source_y, float source_w, float source_h, float position_x, float position_y, float position_z, float size_x, float size_y, int32_t tint_rgba) {
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle source = { source_x, source_y, source_w, source_h };
    Vector3 position = { position_x, position_y, position_z };
    Vector2 size = { size_x, size_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawBillboardRec(camera_value, texture_value, source, position, size, tint);
    return NULL;
}

void* rl2_DrawBoundingBox(float* box, int32_t box_len, int32_t color_rgba) {
    if (box_len < 6) return NULL;
    if (box == NULL) return NULL;
    rl_disturb_float_t* box_src = (rl_disturb_float_t*)(void*)box;
    BoundingBox box_value;
    memset(&box_value, 0, sizeof(box_value));
    box_value.min.x = (float)box_src[0];
    box_value.min.y = (float)box_src[1];
    box_value.min.z = (float)box_src[2];
    box_value.max.x = (float)box_src[3];
    box_value.max.y = (float)box_src[4];
    box_value.max.z = (float)box_src[5];
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawBoundingBox(box_value, color);
    return NULL;
}

void* rl2_DrawCapsule(float startPos_x, float startPos_y, float startPos_z, float endPos_x, float endPos_y, float endPos_z, float radius, int32_t slices, int32_t rings, int32_t color_rgba) {
    Vector3 startPos = { startPos_x, startPos_y, startPos_z };
    Vector3 endPos = { endPos_x, endPos_y, endPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCapsule(startPos, endPos, (float)radius, (int)slices, (int)rings, color);
    return NULL;
}

void* rl2_DrawCapsuleWires(float startPos_x, float startPos_y, float startPos_z, float endPos_x, float endPos_y, float endPos_z, float radius, int32_t slices, int32_t rings, int32_t color_rgba) {
    Vector3 startPos = { startPos_x, startPos_y, startPos_z };
    Vector3 endPos = { endPos_x, endPos_y, endPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCapsuleWires(startPos, endPos, (float)radius, (int)slices, (int)rings, color);
    return NULL;
}

void* rl2_DrawCircle(int32_t centerX, int32_t centerY, float radius, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircle((int)centerX, (int)centerY, (float)radius, color);
    return NULL;
}

void* rl2_DrawCircle3D(float center_x, float center_y, float center_z, float radius, float rotationAxis_x, float rotationAxis_y, float rotationAxis_z, float rotationAngle, int32_t color_rgba) {
    Vector3 center = { center_x, center_y, center_z };
    Vector3 rotationAxis = { rotationAxis_x, rotationAxis_y, rotationAxis_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircle3D(center, (float)radius, rotationAxis, (float)rotationAngle, color);
    return NULL;
}

void* rl2_DrawCircleGradient(int32_t centerX, int32_t centerY, float radius, int32_t inner_rgba, int32_t outer_rgba) {
    Color inner = rl_color_from_rgba_i32(inner_rgba);
    Color outer = rl_color_from_rgba_i32(outer_rgba);
    DrawCircleGradient((int)centerX, (int)centerY, (float)radius, inner, outer);
    return NULL;
}

void* rl2_DrawCircleLines(int32_t centerX, int32_t centerY, float radius, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircleLines((int)centerX, (int)centerY, (float)radius, color);
    return NULL;
}

void* rl2_DrawCircleLinesV(float center_x, float center_y, float radius, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircleLinesV(center, (float)radius, color);
    return NULL;
}

void* rl2_DrawCircleSector(float center_x, float center_y, float radius, float startAngle, float endAngle, int32_t segments, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircleSector(center, (float)radius, (float)startAngle, (float)endAngle, (int)segments, color);
    return NULL;
}

void* rl2_DrawCircleSectorLines(float center_x, float center_y, float radius, float startAngle, float endAngle, int32_t segments, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircleSectorLines(center, (float)radius, (float)startAngle, (float)endAngle, (int)segments, color);
    return NULL;
}

void* rl2_DrawCircleV(float center_x, float center_y, float radius, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCircleV(center, (float)radius, color);
    return NULL;
}

void* rl2_DrawCube(float position_x, float position_y, float position_z, float width, float height, float length, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCube(position, (float)width, (float)height, (float)length, color);
    return NULL;
}

void* rl2_DrawCubeV(float position_x, float position_y, float position_z, float size_x, float size_y, float size_z, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Vector3 size = { size_x, size_y, size_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCubeV(position, size, color);
    return NULL;
}

void* rl2_DrawCubeWires(float position_x, float position_y, float position_z, float width, float height, float length, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCubeWires(position, (float)width, (float)height, (float)length, color);
    return NULL;
}

void* rl2_DrawCubeWiresV(float position_x, float position_y, float position_z, float size_x, float size_y, float size_z, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Vector3 size = { size_x, size_y, size_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCubeWiresV(position, size, color);
    return NULL;
}

void* rl2_DrawCylinder(float position_x, float position_y, float position_z, float radiusTop, float radiusBottom, float height, int32_t slices, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCylinder(position, (float)radiusTop, (float)radiusBottom, (float)height, (int)slices, color);
    return NULL;
}

void* rl2_DrawCylinderEx(float startPos_x, float startPos_y, float startPos_z, float endPos_x, float endPos_y, float endPos_z, float startRadius, float endRadius, int32_t sides, int32_t color_rgba) {
    Vector3 startPos = { startPos_x, startPos_y, startPos_z };
    Vector3 endPos = { endPos_x, endPos_y, endPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCylinderEx(startPos, endPos, (float)startRadius, (float)endRadius, (int)sides, color);
    return NULL;
}

void* rl2_DrawCylinderWires(float position_x, float position_y, float position_z, float radiusTop, float radiusBottom, float height, int32_t slices, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCylinderWires(position, (float)radiusTop, (float)radiusBottom, (float)height, (int)slices, color);
    return NULL;
}

void* rl2_DrawCylinderWiresEx(float startPos_x, float startPos_y, float startPos_z, float endPos_x, float endPos_y, float endPos_z, float startRadius, float endRadius, int32_t sides, int32_t color_rgba) {
    Vector3 startPos = { startPos_x, startPos_y, startPos_z };
    Vector3 endPos = { endPos_x, endPos_y, endPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawCylinderWiresEx(startPos, endPos, (float)startRadius, (float)endRadius, (int)sides, color);
    return NULL;
}

void* rl2_DrawEllipse(int32_t centerX, int32_t centerY, float radiusH, float radiusV, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawEllipse((int)centerX, (int)centerY, (float)radiusH, (float)radiusV, color);
    return NULL;
}

void* rl2_DrawEllipseLines(int32_t centerX, int32_t centerY, float radiusH, float radiusV, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawEllipseLines((int)centerX, (int)centerY, (float)radiusH, (float)radiusV, color);
    return NULL;
}

void* rl2_DrawEllipseLinesV(float center_x, float center_y, float radiusH, float radiusV, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawEllipseLinesV(center, (float)radiusH, (float)radiusV, color);
    return NULL;
}

void* rl2_DrawEllipseV(float center_x, float center_y, float radiusH, float radiusV, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawEllipseV(center, (float)radiusH, (float)radiusV, color);
    return NULL;
}

void* rl2_DrawFPS(int32_t posX, int32_t posY) {
    DrawFPS((int)posX, (int)posY);
    return NULL;
}

void* rl2_DrawGrid(int32_t slices, float spacing) {
    DrawGrid((int)slices, (float)spacing);
    return NULL;
}

void* rl2_DrawLine(int32_t startPosX, int32_t startPosY, int32_t endPosX, int32_t endPosY, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLine((int)startPosX, (int)startPosY, (int)endPosX, (int)endPosY, color);
    return NULL;
}

void* rl2_DrawLine3D(float startPos_x, float startPos_y, float startPos_z, float endPos_x, float endPos_y, float endPos_z, int32_t color_rgba) {
    Vector3 startPos = { startPos_x, startPos_y, startPos_z };
    Vector3 endPos = { endPos_x, endPos_y, endPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLine3D(startPos, endPos, color);
    return NULL;
}

void* rl2_DrawLineBezier(float startPos_x, float startPos_y, float endPos_x, float endPos_y, float thick, int32_t color_rgba) {
    Vector2 startPos = { startPos_x, startPos_y };
    Vector2 endPos = { endPos_x, endPos_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLineBezier(startPos, endPos, (float)thick, color);
    return NULL;
}

void* rl2_DrawLineDashed(float startPos_x, float startPos_y, float endPos_x, float endPos_y, int32_t dashSize, int32_t spaceSize, int32_t color_rgba) {
    Vector2 startPos = { startPos_x, startPos_y };
    Vector2 endPos = { endPos_x, endPos_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLineDashed(startPos, endPos, (int)dashSize, (int)spaceSize, color);
    return NULL;
}

void* rl2_DrawLineEx(float startPos_x, float startPos_y, float endPos_x, float endPos_y, float thick, int32_t color_rgba) {
    Vector2 startPos = { startPos_x, startPos_y };
    Vector2 endPos = { endPos_x, endPos_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLineEx(startPos, endPos, (float)thick, color);
    return NULL;
}

void* rl2_DrawLineStrip(float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawLineStrip((const Vector2*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_DrawLineV(float startPos_x, float startPos_y, float endPos_x, float endPos_y, int32_t color_rgba) {
    Vector2 startPos = { startPos_x, startPos_y };
    Vector2 endPos = { endPos_x, endPos_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawLineV(startPos, endPos, color);
    return NULL;
}

void* rl2_DrawMesh(void* mesh, void* material, float* transform, int32_t transform_len) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    Material material_value;
    memset(&material_value, 0, sizeof(material_value));
    if (material != NULL) {
        material_value = *((Material*)material);
    }
    if (transform_len < 16) return NULL;
    if (transform == NULL) return NULL;
    rl_disturb_float_t* transform_src = (rl_disturb_float_t*)(void*)transform;
    Matrix transform_value;
    memset(&transform_value, 0, sizeof(transform_value));
    transform_value.m0 = (float)transform_src[0];
    transform_value.m1 = (float)transform_src[1];
    transform_value.m2 = (float)transform_src[2];
    transform_value.m3 = (float)transform_src[3];
    transform_value.m4 = (float)transform_src[4];
    transform_value.m5 = (float)transform_src[5];
    transform_value.m6 = (float)transform_src[6];
    transform_value.m7 = (float)transform_src[7];
    transform_value.m8 = (float)transform_src[8];
    transform_value.m9 = (float)transform_src[9];
    transform_value.m10 = (float)transform_src[10];
    transform_value.m11 = (float)transform_src[11];
    transform_value.m12 = (float)transform_src[12];
    transform_value.m13 = (float)transform_src[13];
    transform_value.m14 = (float)transform_src[14];
    transform_value.m15 = (float)transform_src[15];
    DrawMesh(mesh_value, material_value, transform_value);
    return NULL;
}

void* rl2_DrawMeshInstanced(void* mesh, void* material, float* transforms, int32_t instances) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    Material material_value;
    memset(&material_value, 0, sizeof(material_value));
    if (material != NULL) {
        material_value = *((Material*)material);
    }
    if (instances < 0) return NULL;
    if (instances > 0 && transforms == NULL) return NULL;
    DrawMeshInstanced(mesh_value, material_value, (const Matrix*)transforms, (int)instances);
    return NULL;
}

void* rl2_DrawModel(void* model, float position_x, float position_y, float position_z, float scale, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModel(model_value, position, (float)scale, tint);
    return NULL;
}

void* rl2_DrawModelEx(void* model, float position_x, float position_y, float position_z, float rotationAxis_x, float rotationAxis_y, float rotationAxis_z, float rotationAngle, float scale_x, float scale_y, float scale_z, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Vector3 rotationAxis = { rotationAxis_x, rotationAxis_y, rotationAxis_z };
    Vector3 scale = { scale_x, scale_y, scale_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModelEx(model_value, position, rotationAxis, (float)rotationAngle, scale, tint);
    return NULL;
}

void* rl2_DrawModelPoints(void* model, float position_x, float position_y, float position_z, float scale, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModelPoints(model_value, position, (float)scale, tint);
    return NULL;
}

void* rl2_DrawModelPointsEx(void* model, float position_x, float position_y, float position_z, float rotationAxis_x, float rotationAxis_y, float rotationAxis_z, float rotationAngle, float scale_x, float scale_y, float scale_z, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Vector3 rotationAxis = { rotationAxis_x, rotationAxis_y, rotationAxis_z };
    Vector3 scale = { scale_x, scale_y, scale_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModelPointsEx(model_value, position, rotationAxis, (float)rotationAngle, scale, tint);
    return NULL;
}

void* rl2_DrawModelWires(void* model, float position_x, float position_y, float position_z, float scale, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModelWires(model_value, position, (float)scale, tint);
    return NULL;
}

void* rl2_DrawModelWiresEx(void* model, float position_x, float position_y, float position_z, float rotationAxis_x, float rotationAxis_y, float rotationAxis_z, float rotationAngle, float scale_x, float scale_y, float scale_z, int32_t tint_rgba) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    Vector3 position = { position_x, position_y, position_z };
    Vector3 rotationAxis = { rotationAxis_x, rotationAxis_y, rotationAxis_z };
    Vector3 scale = { scale_x, scale_y, scale_z };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawModelWiresEx(model_value, position, rotationAxis, (float)rotationAngle, scale, tint);
    return NULL;
}

void* rl2_DrawPixel(int32_t posX, int32_t posY, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPixel((int)posX, (int)posY, color);
    return NULL;
}

void* rl2_DrawPixelV(float position_x, float position_y, int32_t color_rgba) {
    Vector2 position = { position_x, position_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPixelV(position, color);
    return NULL;
}

void* rl2_DrawPlane(float centerPos_x, float centerPos_y, float centerPos_z, float size_x, float size_y, int32_t color_rgba) {
    Vector3 centerPos = { centerPos_x, centerPos_y, centerPos_z };
    Vector2 size = { size_x, size_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPlane(centerPos, size, color);
    return NULL;
}

void* rl2_DrawPoint3D(float position_x, float position_y, float position_z, int32_t color_rgba) {
    Vector3 position = { position_x, position_y, position_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPoint3D(position, color);
    return NULL;
}

void* rl2_DrawPoly(float center_x, float center_y, int32_t sides, float radius, float rotation, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPoly(center, (int)sides, (float)radius, (float)rotation, color);
    return NULL;
}

void* rl2_DrawPolyLines(float center_x, float center_y, int32_t sides, float radius, float rotation, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPolyLines(center, (int)sides, (float)radius, (float)rotation, color);
    return NULL;
}

void* rl2_DrawPolyLinesEx(float center_x, float center_y, int32_t sides, float radius, float rotation, float lineThick, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawPolyLinesEx(center, (int)sides, (float)radius, (float)rotation, (float)lineThick, color);
    return NULL;
}

void* rl2_DrawRay(void* ray, int32_t color_rgba) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRay(ray_value, color);
    return NULL;
}

void* rl2_DrawRectangle(int32_t posX, int32_t posY, int32_t width, int32_t height, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangle((int)posX, (int)posY, (int)width, (int)height, color);
    return NULL;
}

void* rl2_DrawRectangleGradientEx(float rec_x, float rec_y, float rec_w, float rec_h, int32_t topLeft_rgba, int32_t bottomLeft_rgba, int32_t bottomRight_rgba, int32_t topRight_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color topLeft = rl_color_from_rgba_i32(topLeft_rgba);
    Color bottomLeft = rl_color_from_rgba_i32(bottomLeft_rgba);
    Color bottomRight = rl_color_from_rgba_i32(bottomRight_rgba);
    Color topRight = rl_color_from_rgba_i32(topRight_rgba);
    DrawRectangleGradientEx(rec, topLeft, bottomLeft, bottomRight, topRight);
    return NULL;
}

void* rl2_DrawRectangleGradientH(int32_t posX, int32_t posY, int32_t width, int32_t height, int32_t left_rgba, int32_t right_rgba) {
    Color left = rl_color_from_rgba_i32(left_rgba);
    Color right = rl_color_from_rgba_i32(right_rgba);
    DrawRectangleGradientH((int)posX, (int)posY, (int)width, (int)height, left, right);
    return NULL;
}

void* rl2_DrawRectangleGradientV(int32_t posX, int32_t posY, int32_t width, int32_t height, int32_t top_rgba, int32_t bottom_rgba) {
    Color top = rl_color_from_rgba_i32(top_rgba);
    Color bottom = rl_color_from_rgba_i32(bottom_rgba);
    DrawRectangleGradientV((int)posX, (int)posY, (int)width, (int)height, top, bottom);
    return NULL;
}

void* rl2_DrawRectangleLines(int32_t posX, int32_t posY, int32_t width, int32_t height, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleLines((int)posX, (int)posY, (int)width, (int)height, color);
    return NULL;
}

void* rl2_DrawRectangleLinesEx(float rec_x, float rec_y, float rec_w, float rec_h, float lineThick, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleLinesEx(rec, (float)lineThick, color);
    return NULL;
}

void* rl2_DrawRectanglePro(float rec_x, float rec_y, float rec_w, float rec_h, float origin_x, float origin_y, float rotation, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Vector2 origin = { origin_x, origin_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectanglePro(rec, origin, (float)rotation, color);
    return NULL;
}

void* rl2_DrawRectangleRec(float rec_x, float rec_y, float rec_w, float rec_h, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleRec(rec, color);
    return NULL;
}

void* rl2_DrawRectangleRounded(float rec_x, float rec_y, float rec_w, float rec_h, float roundness, int32_t segments, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleRounded(rec, (float)roundness, (int)segments, color);
    return NULL;
}

void* rl2_DrawRectangleRoundedLines(float rec_x, float rec_y, float rec_w, float rec_h, float roundness, int32_t segments, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleRoundedLines(rec, (float)roundness, (int)segments, color);
    return NULL;
}

void* rl2_DrawRectangleRoundedLinesEx(float rec_x, float rec_y, float rec_w, float rec_h, float roundness, int32_t segments, float lineThick, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleRoundedLinesEx(rec, (float)roundness, (int)segments, (float)lineThick, color);
    return NULL;
}

void* rl2_DrawRectangleV(float position_x, float position_y, float size_x, float size_y, int32_t color_rgba) {
    Vector2 position = { position_x, position_y };
    Vector2 size = { size_x, size_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRectangleV(position, size, color);
    return NULL;
}

void* rl2_DrawRing(float center_x, float center_y, float innerRadius, float outerRadius, float startAngle, float endAngle, int32_t segments, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRing(center, (float)innerRadius, (float)outerRadius, (float)startAngle, (float)endAngle, (int)segments, color);
    return NULL;
}

void* rl2_DrawRingLines(float center_x, float center_y, float innerRadius, float outerRadius, float startAngle, float endAngle, int32_t segments, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawRingLines(center, (float)innerRadius, (float)outerRadius, (float)startAngle, (float)endAngle, (int)segments, color);
    return NULL;
}

void* rl2_DrawSphere(float centerPos_x, float centerPos_y, float centerPos_z, float radius, int32_t color_rgba) {
    Vector3 centerPos = { centerPos_x, centerPos_y, centerPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSphere(centerPos, (float)radius, color);
    return NULL;
}

void* rl2_DrawSphereEx(float centerPos_x, float centerPos_y, float centerPos_z, float radius, int32_t rings, int32_t slices, int32_t color_rgba) {
    Vector3 centerPos = { centerPos_x, centerPos_y, centerPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSphereEx(centerPos, (float)radius, (int)rings, (int)slices, color);
    return NULL;
}

void* rl2_DrawSphereWires(float centerPos_x, float centerPos_y, float centerPos_z, float radius, int32_t rings, int32_t slices, int32_t color_rgba) {
    Vector3 centerPos = { centerPos_x, centerPos_y, centerPos_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSphereWires(centerPos, (float)radius, (int)rings, (int)slices, color);
    return NULL;
}

void* rl2_DrawSplineBasis(float* points, int32_t pointCount, float thick, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawSplineBasis((const Vector2*)points, (int)pointCount, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineBezierCubic(float* points, int32_t pointCount, float thick, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawSplineBezierCubic((const Vector2*)points, (int)pointCount, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineBezierQuadratic(float* points, int32_t pointCount, float thick, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawSplineBezierQuadratic((const Vector2*)points, (int)pointCount, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineCatmullRom(float* points, int32_t pointCount, float thick, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawSplineCatmullRom((const Vector2*)points, (int)pointCount, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineLinear(float* points, int32_t pointCount, float thick, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawSplineLinear((const Vector2*)points, (int)pointCount, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineSegmentBasis(float p1_x, float p1_y, float p2_x, float p2_y, float p3_x, float p3_y, float p4_x, float p4_y, float thick, int32_t color_rgba) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Vector2 p3 = { p3_x, p3_y };
    Vector2 p4 = { p4_x, p4_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSplineSegmentBasis(p1, p2, p3, p4, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineSegmentBezierCubic(float p1_x, float p1_y, float c2_x, float c2_y, float c3_x, float c3_y, float p4_x, float p4_y, float thick, int32_t color_rgba) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 c2 = { c2_x, c2_y };
    Vector2 c3 = { c3_x, c3_y };
    Vector2 p4 = { p4_x, p4_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSplineSegmentBezierCubic(p1, c2, c3, p4, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineSegmentBezierQuadratic(float p1_x, float p1_y, float c2_x, float c2_y, float p3_x, float p3_y, float thick, int32_t color_rgba) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 c2 = { c2_x, c2_y };
    Vector2 p3 = { p3_x, p3_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSplineSegmentBezierQuadratic(p1, c2, p3, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineSegmentCatmullRom(float p1_x, float p1_y, float p2_x, float p2_y, float p3_x, float p3_y, float p4_x, float p4_y, float thick, int32_t color_rgba) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Vector2 p3 = { p3_x, p3_y };
    Vector2 p4 = { p4_x, p4_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSplineSegmentCatmullRom(p1, p2, p3, p4, (float)thick, color);
    return NULL;
}

void* rl2_DrawSplineSegmentLinear(float p1_x, float p1_y, float p2_x, float p2_y, float thick, int32_t color_rgba) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawSplineSegmentLinear(p1, p2, (float)thick, color);
    return NULL;
}

void* rl2_DrawText(char* text, int32_t posX, int32_t posY, int32_t fontSize, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawText((const char*)text, (int)posX, (int)posY, (int)fontSize, color);
    return NULL;
}

void* rl2_DrawTextCodepoint(void* font, int32_t codepoint, float position_x, float position_y, float fontSize, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextCodepoint(font_value, (int)codepoint, position, (float)fontSize, tint);
    return NULL;
}

void* rl2_DrawTextCodepoints(void* font, int32_t* codepoints, int32_t codepointCount, float position_x, float position_y, float fontSize, float spacing, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && codepoints == NULL) return NULL;
    DrawTextCodepoints(font_value, (const int*)codepoints, (int)codepointCount, position, (float)fontSize, (float)spacing, tint);
    return NULL;
}

void* rl2_DrawTextEx(void* font, char* text, float position_x, float position_y, float fontSize, float spacing, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextEx(font_value, (const char*)text, position, (float)fontSize, (float)spacing, tint);
    return NULL;
}

void* rl2_DrawTextPro(void* font, char* text, float position_x, float position_y, float origin_x, float origin_y, float rotation, float fontSize, float spacing, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Vector2 position = { position_x, position_y };
    Vector2 origin = { origin_x, origin_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextPro(font_value, (const char*)text, position, origin, (float)rotation, (float)fontSize, (float)spacing, tint);
    return NULL;
}

void* rl2_DrawTexture(void* texture, int32_t posX, int32_t posY, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTexture(texture_value, (int)posX, (int)posY, tint);
    return NULL;
}

void* rl2_DrawTextureEx(void* texture, float position_x, float position_y, float rotation, float scale, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextureEx(texture_value, position, (float)rotation, (float)scale, tint);
    return NULL;
}

void* rl2_DrawTextureNPatch(void* texture, void* nPatchInfo, float dest_x, float dest_y, float dest_w, float dest_h, float origin_x, float origin_y, float rotation, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    NPatchInfo nPatchInfo_value;
    memset(&nPatchInfo_value, 0, sizeof(nPatchInfo_value));
    if (nPatchInfo != NULL) {
        nPatchInfo_value = *((NPatchInfo*)nPatchInfo);
    }
    Rectangle dest = { dest_x, dest_y, dest_w, dest_h };
    Vector2 origin = { origin_x, origin_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextureNPatch(texture_value, nPatchInfo_value, dest, origin, (float)rotation, tint);
    return NULL;
}

void* rl2_DrawTexturePro(void* texture, float source_x, float source_y, float source_w, float source_h, float dest_x, float dest_y, float dest_w, float dest_h, float origin_x, float origin_y, float rotation, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle source = { source_x, source_y, source_w, source_h };
    Rectangle dest = { dest_x, dest_y, dest_w, dest_h };
    Vector2 origin = { origin_x, origin_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTexturePro(texture_value, source, dest, origin, (float)rotation, tint);
    return NULL;
}

void* rl2_DrawTextureRec(void* texture, float source_x, float source_y, float source_w, float source_h, float position_x, float position_y, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle source = { source_x, source_y, source_w, source_h };
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextureRec(texture_value, source, position, tint);
    return NULL;
}

void* rl2_DrawTextureV(void* texture, float position_x, float position_y, int32_t tint_rgba) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    DrawTextureV(texture_value, position, tint);
    return NULL;
}

void* rl2_DrawTriangle(float v1_x, float v1_y, float v2_x, float v2_y, float v3_x, float v3_y, int32_t color_rgba) {
    Vector2 v1 = { v1_x, v1_y };
    Vector2 v2 = { v2_x, v2_y };
    Vector2 v3 = { v3_x, v3_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawTriangle(v1, v2, v3, color);
    return NULL;
}

void* rl2_DrawTriangle3D(float v1_x, float v1_y, float v1_z, float v2_x, float v2_y, float v2_z, float v3_x, float v3_y, float v3_z, int32_t color_rgba) {
    Vector3 v1 = { v1_x, v1_y, v1_z };
    Vector3 v2 = { v2_x, v2_y, v2_z };
    Vector3 v3 = { v3_x, v3_y, v3_z };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawTriangle3D(v1, v2, v3, color);
    return NULL;
}

void* rl2_DrawTriangleFan(float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawTriangleFan((const Vector2*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_DrawTriangleLines(float v1_x, float v1_y, float v2_x, float v2_y, float v3_x, float v3_y, int32_t color_rgba) {
    Vector2 v1 = { v1_x, v1_y };
    Vector2 v2 = { v2_x, v2_y };
    Vector2 v3 = { v3_x, v3_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    DrawTriangleLines(v1, v2, v3, color);
    return NULL;
}

void* rl2_DrawTriangleStrip(float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawTriangleStrip((const Vector2*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_DrawTriangleStrip3D(float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    DrawTriangleStrip3D((const Vector3*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_EnableCursor(void) {
    EnableCursor();
    return NULL;
}

void* rl2_EnableEventWaiting(void) {
    EnableEventWaiting();
    return NULL;
}

char* rl2_EncodeDataBase64(int32_t* data, int32_t dataSize, int32_t* outputSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    return (char*)EncodeDataBase64((const unsigned char*)data, (int)dataSize, (int*)outputSize);
}

void* rl2_EndBlendMode(void) {
    EndBlendMode();
    return NULL;
}

void* rl2_EndDrawing(void) {
    EndDrawing();
    return NULL;
}

void* rl2_EndMode2D(void) {
    EndMode2D();
    return NULL;
}

void* rl2_EndMode3D(void) {
    EndMode3D();
    return NULL;
}

void* rl2_EndScissorMode(void) {
    EndScissorMode();
    return NULL;
}

void* rl2_EndShaderMode(void) {
    EndShaderMode();
    return NULL;
}

void* rl2_EndTextureMode(void) {
    EndTextureMode();
    return NULL;
}

void* rl2_EndVrStereoMode(void) {
    EndVrStereoMode();
    return NULL;
}

int32_t rl2_ExportAutomationEventList(void* list, char* fileName) {
    AutomationEventList list_value;
    memset(&list_value, 0, sizeof(list_value));
    if (list != NULL) {
        list_value = *((AutomationEventList*)list);
    }
    return ExportAutomationEventList(list_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportDataAsCode(int32_t* data, int32_t dataSize, char* fileName) {
    if (dataSize < 0) return 0;
    if (dataSize > 0 && data == NULL) return 0;
    return ExportDataAsCode((const unsigned char*)data, (int)dataSize, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportFontAsCode(void* font, char* fileName) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    return ExportFontAsCode(font_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportImage(void* image, char* fileName) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    return ExportImage(image_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportImageAsCode(void* image, char* fileName) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    return ExportImageAsCode(image_value, (const char*)fileName) ? 1 : 0;
}

void* rl2_ExportImageToMemory(void* image, char* fileType, int32_t* fileSize, int32_t fileSize_len) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    if (fileSize_len < 1) return NULL;
    if (fileSize == NULL) return NULL;
    return (void*)ExportImageToMemory(image_value, (const char*)fileType, (int*)fileSize);
}

int32_t rl2_ExportMesh(void* mesh, char* fileName) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    return ExportMesh(mesh_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportMeshAsCode(void* mesh, char* fileName) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    return ExportMeshAsCode(mesh_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportWave(void* wave, char* fileName) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    return ExportWave(wave_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_ExportWaveAsCode(void* wave, char* fileName) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    return ExportWaveAsCode(wave_value, (const char*)fileName) ? 1 : 0;
}

int32_t rl2_Fade(int32_t color_rgba, float alpha, int32_t* ret_out, int32_t ret_out_len) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = Fade(color, (float)alpha);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_FileCopy(char* srcPath, char* dstPath) {
    return (int32_t)FileCopy((const char*)srcPath, (const char*)dstPath);
}

int32_t rl2_FileExists(char* fileName) {
    return FileExists((const char*)fileName) ? 1 : 0;
}

int32_t rl2_FileMove(char* srcPath, char* dstPath) {
    return (int32_t)FileMove((const char*)srcPath, (const char*)dstPath);
}

int32_t rl2_FileRemove(char* fileName) {
    return (int32_t)FileRemove((const char*)fileName);
}

int32_t rl2_FileRename(char* fileName, char* fileRename) {
    return (int32_t)FileRename((const char*)fileName, (const char*)fileRename);
}

int32_t rl2_FileTextFindIndex(char* fileName, char* search) {
    return (int32_t)FileTextFindIndex((const char*)fileName, (const char*)search);
}

int32_t rl2_FileTextReplace(char* fileName, char* search, char* replacement) {
    return (int32_t)FileTextReplace((const char*)fileName, (const char*)search, (const char*)replacement);
}

void* rl2_GenImageCellular(int32_t width, int32_t height, int32_t tileSize) {
    Image rl_value = GenImageCellular((int)width, (int)height, (int)tileSize);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageChecked(int32_t width, int32_t height, int32_t checksX, int32_t checksY, int32_t col1_rgba, int32_t col2_rgba) {
    Color col1 = rl_color_from_rgba_i32(col1_rgba);
    Color col2 = rl_color_from_rgba_i32(col2_rgba);
    Image rl_value = GenImageChecked((int)width, (int)height, (int)checksX, (int)checksY, col1, col2);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageColor(int32_t width, int32_t height, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    Image rl_value = GenImageColor((int)width, (int)height, color);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageFontAtlas(void* glyphs, void* glyphRecs, int32_t glyphCount, int32_t fontSize, int32_t padding, int32_t packMethod) {
    Image rl_value = GenImageFontAtlas((const GlyphInfo*)glyphs, (Rectangle**)glyphRecs, (int)glyphCount, (int)fontSize, (int)padding, (int)packMethod);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageGradientLinear(int32_t width, int32_t height, int32_t direction, int32_t start_rgba, int32_t end_rgba) {
    Color start = rl_color_from_rgba_i32(start_rgba);
    Color end = rl_color_from_rgba_i32(end_rgba);
    Image rl_value = GenImageGradientLinear((int)width, (int)height, (int)direction, start, end);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageGradientRadial(int32_t width, int32_t height, float density, int32_t inner_rgba, int32_t outer_rgba) {
    Color inner = rl_color_from_rgba_i32(inner_rgba);
    Color outer = rl_color_from_rgba_i32(outer_rgba);
    Image rl_value = GenImageGradientRadial((int)width, (int)height, (float)density, inner, outer);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageGradientSquare(int32_t width, int32_t height, float density, int32_t inner_rgba, int32_t outer_rgba) {
    Color inner = rl_color_from_rgba_i32(inner_rgba);
    Color outer = rl_color_from_rgba_i32(outer_rgba);
    Image rl_value = GenImageGradientSquare((int)width, (int)height, (float)density, inner, outer);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImagePerlinNoise(int32_t width, int32_t height, int32_t offsetX, int32_t offsetY, float scale) {
    Image rl_value = GenImagePerlinNoise((int)width, (int)height, (int)offsetX, (int)offsetY, (float)scale);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageText(int32_t width, int32_t height, char* text) {
    Image rl_value = GenImageText((int)width, (int)height, (const char*)text);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenImageWhiteNoise(int32_t width, int32_t height, float factor) {
    Image rl_value = GenImageWhiteNoise((int)width, (int)height, (float)factor);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshCone(float radius, float height, int32_t slices) {
    Mesh rl_value = GenMeshCone((float)radius, (float)height, (int)slices);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshCube(float width, float height, float length) {
    Mesh rl_value = GenMeshCube((float)width, (float)height, (float)length);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshCubicmap(void* cubicmap, float cubeSize_x, float cubeSize_y, float cubeSize_z) {
    Image cubicmap_value;
    memset(&cubicmap_value, 0, sizeof(cubicmap_value));
    if (cubicmap != NULL) {
        cubicmap_value = *((Image*)cubicmap);
    }
    Vector3 cubeSize = { cubeSize_x, cubeSize_y, cubeSize_z };
    Mesh rl_value = GenMeshCubicmap(cubicmap_value, cubeSize);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshCylinder(float radius, float height, int32_t slices) {
    Mesh rl_value = GenMeshCylinder((float)radius, (float)height, (int)slices);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshHeightmap(void* heightmap, float size_x, float size_y, float size_z) {
    Image heightmap_value;
    memset(&heightmap_value, 0, sizeof(heightmap_value));
    if (heightmap != NULL) {
        heightmap_value = *((Image*)heightmap);
    }
    Vector3 size = { size_x, size_y, size_z };
    Mesh rl_value = GenMeshHeightmap(heightmap_value, size);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshHemiSphere(float radius, int32_t rings, int32_t slices) {
    Mesh rl_value = GenMeshHemiSphere((float)radius, (int)rings, (int)slices);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshKnot(float radius, float size, int32_t radSeg, int32_t sides) {
    Mesh rl_value = GenMeshKnot((float)radius, (float)size, (int)radSeg, (int)sides);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshPlane(float width, float length, int32_t resX, int32_t resZ) {
    Mesh rl_value = GenMeshPlane((float)width, (float)length, (int)resX, (int)resZ);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshPoly(int32_t sides, float radius) {
    Mesh rl_value = GenMeshPoly((int)sides, (float)radius);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshSphere(float radius, int32_t rings, int32_t slices) {
    Mesh rl_value = GenMeshSphere((float)radius, (int)rings, (int)slices);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenMeshTangents(void* mesh) {
    GenMeshTangents((Mesh*)mesh);
    return NULL;
}

void* rl2_GenMeshTorus(float radius, float size, int32_t radSeg, int32_t sides) {
    Mesh rl_value = GenMeshTorus((float)radius, (float)size, (int)radSeg, (int)sides);
    Mesh* rl_heap = (Mesh*)malloc(sizeof(Mesh));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GenTextureMipmaps(void* texture) {
    GenTextureMipmaps((Texture2D*)texture);
    return NULL;
}

char* rl2_GetApplicationDirectory(void) {
    return (char*)GetApplicationDirectory();
}

int32_t rl2_GetCameraMatrix(void* camera, float* ret_out, int32_t ret_out_len) {
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    if (ret_out_len < 16) return 0;
    if (ret_out == NULL) return 0;
    Matrix rl_value = GetCameraMatrix(camera_value);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.m0;
    rl_out[1] = (rl_disturb_float_t)rl_value.m1;
    rl_out[2] = (rl_disturb_float_t)rl_value.m2;
    rl_out[3] = (rl_disturb_float_t)rl_value.m3;
    rl_out[4] = (rl_disturb_float_t)rl_value.m4;
    rl_out[5] = (rl_disturb_float_t)rl_value.m5;
    rl_out[6] = (rl_disturb_float_t)rl_value.m6;
    rl_out[7] = (rl_disturb_float_t)rl_value.m7;
    rl_out[8] = (rl_disturb_float_t)rl_value.m8;
    rl_out[9] = (rl_disturb_float_t)rl_value.m9;
    rl_out[10] = (rl_disturb_float_t)rl_value.m10;
    rl_out[11] = (rl_disturb_float_t)rl_value.m11;
    rl_out[12] = (rl_disturb_float_t)rl_value.m12;
    rl_out[13] = (rl_disturb_float_t)rl_value.m13;
    rl_out[14] = (rl_disturb_float_t)rl_value.m14;
    rl_out[15] = (rl_disturb_float_t)rl_value.m15;
    return 1;
}

int32_t rl2_GetCameraMatrix2D(void* camera, float* ret_out, int32_t ret_out_len) {
    Camera2D camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera2D*)camera);
    }
    if (ret_out_len < 16) return 0;
    if (ret_out == NULL) return 0;
    Matrix rl_value = GetCameraMatrix2D(camera_value);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.m0;
    rl_out[1] = (rl_disturb_float_t)rl_value.m1;
    rl_out[2] = (rl_disturb_float_t)rl_value.m2;
    rl_out[3] = (rl_disturb_float_t)rl_value.m3;
    rl_out[4] = (rl_disturb_float_t)rl_value.m4;
    rl_out[5] = (rl_disturb_float_t)rl_value.m5;
    rl_out[6] = (rl_disturb_float_t)rl_value.m6;
    rl_out[7] = (rl_disturb_float_t)rl_value.m7;
    rl_out[8] = (rl_disturb_float_t)rl_value.m8;
    rl_out[9] = (rl_disturb_float_t)rl_value.m9;
    rl_out[10] = (rl_disturb_float_t)rl_value.m10;
    rl_out[11] = (rl_disturb_float_t)rl_value.m11;
    rl_out[12] = (rl_disturb_float_t)rl_value.m12;
    rl_out[13] = (rl_disturb_float_t)rl_value.m13;
    rl_out[14] = (rl_disturb_float_t)rl_value.m14;
    rl_out[15] = (rl_disturb_float_t)rl_value.m15;
    return 1;
}

int32_t rl2_GetCharPressed(void) {
    return (int32_t)GetCharPressed();
}

void* rl2_GetClipboardImage(void) {
    Image rl_value = GetClipboardImage();
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

char* rl2_GetClipboardText(void) {
    return (char*)GetClipboardText();
}

int32_t rl2_GetCodepoint(char* text, int32_t* codepointSize, int32_t codepointSize_len) {
    if (codepointSize_len < 1) return 0;
    if (codepointSize == NULL) return 0;
    return (int32_t)GetCodepoint((const char*)text, (int*)codepointSize);
}

int32_t rl2_GetCodepointCount(char* text) {
    return (int32_t)GetCodepointCount((const char*)text);
}

int32_t rl2_GetCodepointNext(char* text, int32_t* codepointSize, int32_t codepointSize_len) {
    if (codepointSize_len < 1) return 0;
    if (codepointSize == NULL) return 0;
    return (int32_t)GetCodepointNext((const char*)text, (int*)codepointSize);
}

int32_t rl2_GetCodepointPrevious(char* text, int32_t* codepointSize, int32_t codepointSize_len) {
    if (codepointSize_len < 1) return 0;
    if (codepointSize == NULL) return 0;
    return (int32_t)GetCodepointPrevious((const char*)text, (int*)codepointSize);
}

int32_t rl2_GetCollisionRec(float rec1_x, float rec1_y, float rec1_w, float rec1_h, float rec2_x, float rec2_y, float rec2_w, float rec2_h, float* ret_out, int32_t ret_out_len) {
    Rectangle rec1 = { rec1_x, rec1_y, rec1_w, rec1_h };
    Rectangle rec2 = { rec2_x, rec2_y, rec2_w, rec2_h };
    if (ret_out_len < 4) return 0;
    if (ret_out == NULL) return 0;
    Rectangle rl_value = GetCollisionRec(rec1, rec2);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.width;
    rl_out[3] = (rl_disturb_float_t)rl_value.height;
    return 1;
}

int32_t rl2_GetColor(int32_t hexValue, int32_t* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = GetColor((unsigned int)hexValue);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_GetCurrentMonitor(void) {
    return (int32_t)GetCurrentMonitor();
}

int32_t rl2_GetDirectoryFileCount(char* dirPath) {
    return (int32_t)GetDirectoryFileCount((const char*)dirPath);
}

int32_t rl2_GetDirectoryFileCountEx(char* basePath, char* filter, int32_t scanSubdirs) {
    return (int32_t)GetDirectoryFileCountEx((const char*)basePath, (const char*)filter, (bool)scanSubdirs);
}

char* rl2_GetDirectoryPath(char* filePath) {
    return (char*)GetDirectoryPath((const char*)filePath);
}

int32_t rl2_GetFPS(void) {
    return (int32_t)GetFPS();
}

char* rl2_GetFileExtension(char* fileName) {
    return (char*)GetFileExtension((const char*)fileName);
}

int32_t rl2_GetFileLength(char* fileName) {
    return (int32_t)GetFileLength((const char*)fileName);
}

int32_t rl2_GetFileModTime(char* fileName) {
    return (int32_t)GetFileModTime((const char*)fileName);
}

char* rl2_GetFileName(char* filePath) {
    return (char*)GetFileName((const char*)filePath);
}

char* rl2_GetFileNameWithoutExt(char* filePath) {
    return (char*)GetFileNameWithoutExt((const char*)filePath);
}

void* rl2_GetFontDefault(void) {
    Font rl_value = GetFontDefault();
    Font* rl_heap = (Font*)malloc(sizeof(Font));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

float rl2_GetFrameTime(void) {
    return (float)GetFrameTime();
}

int32_t rl2_GetGamepadAxisCount(int32_t gamepad) {
    return (int32_t)GetGamepadAxisCount((int)gamepad);
}

float rl2_GetGamepadAxisMovement(int32_t gamepad, int32_t axis) {
    return (float)GetGamepadAxisMovement((int)gamepad, (int)axis);
}

int32_t rl2_GetGamepadButtonPressed(void) {
    return (int32_t)GetGamepadButtonPressed();
}

char* rl2_GetGamepadName(int32_t gamepad) {
    return (char*)GetGamepadName((int)gamepad);
}

int32_t rl2_GetGestureDetected(void) {
    return (int32_t)GetGestureDetected();
}

float rl2_GetGestureDragAngle(void) {
    return (float)GetGestureDragAngle();
}

int32_t rl2_GetGestureDragVector(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetGestureDragVector();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

float rl2_GetGestureHoldDuration(void) {
    return (float)GetGestureHoldDuration();
}

float rl2_GetGesturePinchAngle(void) {
    return (float)GetGesturePinchAngle();
}

int32_t rl2_GetGesturePinchVector(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetGesturePinchVector();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetGlyphAtlasRec(void* font, int32_t codepoint, float* ret_out, int32_t ret_out_len) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    if (ret_out_len < 4) return 0;
    if (ret_out == NULL) return 0;
    Rectangle rl_value = GetGlyphAtlasRec(font_value, (int)codepoint);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.width;
    rl_out[3] = (rl_disturb_float_t)rl_value.height;
    return 1;
}

int32_t rl2_GetGlyphIndex(void* font, int32_t codepoint) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    return (int32_t)GetGlyphIndex(font_value, (int)codepoint);
}

void* rl2_GetGlyphInfo(void* font, int32_t codepoint) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    GlyphInfo rl_value = GetGlyphInfo(font_value, (int)codepoint);
    GlyphInfo* rl_heap = (GlyphInfo*)malloc(sizeof(GlyphInfo));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

int32_t rl2_GetImageAlphaBorder(void* image, float threshold, float* ret_out, int32_t ret_out_len) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    if (ret_out_len < 4) return 0;
    if (ret_out == NULL) return 0;
    Rectangle rl_value = GetImageAlphaBorder(image_value, (float)threshold);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.width;
    rl_out[3] = (rl_disturb_float_t)rl_value.height;
    return 1;
}

int32_t rl2_GetImageColor(void* image, int32_t x, int32_t y, int32_t* ret_out, int32_t ret_out_len) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = GetImageColor(image_value, (int)x, (int)y);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

char* rl2_GetKeyName(int32_t key) {
    return (char*)GetKeyName((int)key);
}

int32_t rl2_GetKeyPressed(void) {
    return (int32_t)GetKeyPressed();
}

float rl2_GetMasterVolume(void) {
    return (float)GetMasterVolume();
}

void* rl2_GetMeshBoundingBox(void* mesh) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    BoundingBox rl_value = GetMeshBoundingBox(mesh_value);
    BoundingBox* rl_heap = (BoundingBox*)malloc(sizeof(BoundingBox));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetModelBoundingBox(void* model) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    BoundingBox rl_value = GetModelBoundingBox(model_value);
    BoundingBox* rl_heap = (BoundingBox*)malloc(sizeof(BoundingBox));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

int32_t rl2_GetMonitorCount(void) {
    return (int32_t)GetMonitorCount();
}

int32_t rl2_GetMonitorHeight(int32_t monitor) {
    return (int32_t)GetMonitorHeight((int)monitor);
}

char* rl2_GetMonitorName(int32_t monitor) {
    return (char*)GetMonitorName((int)monitor);
}

int32_t rl2_GetMonitorPhysicalHeight(int32_t monitor) {
    return (int32_t)GetMonitorPhysicalHeight((int)monitor);
}

int32_t rl2_GetMonitorPhysicalWidth(int32_t monitor) {
    return (int32_t)GetMonitorPhysicalWidth((int)monitor);
}

int32_t rl2_GetMonitorPosition(int32_t monitor, float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetMonitorPosition((int)monitor);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetMonitorRefreshRate(int32_t monitor) {
    return (int32_t)GetMonitorRefreshRate((int)monitor);
}

int32_t rl2_GetMonitorWidth(int32_t monitor) {
    return (int32_t)GetMonitorWidth((int)monitor);
}

int32_t rl2_GetMouseDelta(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetMouseDelta();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetMousePosition(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetMousePosition();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

float rl2_GetMouseWheelMove(void) {
    return (float)GetMouseWheelMove();
}

int32_t rl2_GetMouseWheelMoveV(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetMouseWheelMoveV();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetMouseX(void) {
    return (int32_t)GetMouseX();
}

int32_t rl2_GetMouseY(void) {
    return (int32_t)GetMouseY();
}

float rl2_GetMusicTimeLength(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    return (float)GetMusicTimeLength(music_value);
}

float rl2_GetMusicTimePlayed(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    return (float)GetMusicTimePlayed(music_value);
}

int32_t rl2_GetPixelColor(void* srcPtr, int32_t format, int32_t* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 1) return 0;
    if (ret_out == NULL) return 0;
    Color rl_value = GetPixelColor((void*)srcPtr, (int)format);
    rl_disturb_int_t* rl_out = (rl_disturb_int_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_int_t)rl_rgba_i32_from_color(rl_value);
    return 1;
}

int32_t rl2_GetPixelDataSize(int32_t width, int32_t height, int32_t format) {
    return (int32_t)GetPixelDataSize((int)width, (int)height, (int)format);
}

char* rl2_GetPrevDirectoryPath(char* dirPath) {
    return (char*)GetPrevDirectoryPath((const char*)dirPath);
}

int32_t rl2_GetRandomValue(int32_t min, int32_t max) {
    return (int32_t)GetRandomValue((int)min, (int)max);
}

void* rl2_GetRayCollisionBox(void* ray, float* box, int32_t box_len) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    if (box_len < 6) return NULL;
    if (box == NULL) return NULL;
    rl_disturb_float_t* box_src = (rl_disturb_float_t*)(void*)box;
    BoundingBox box_value;
    memset(&box_value, 0, sizeof(box_value));
    box_value.min.x = (float)box_src[0];
    box_value.min.y = (float)box_src[1];
    box_value.min.z = (float)box_src[2];
    box_value.max.x = (float)box_src[3];
    box_value.max.y = (float)box_src[4];
    box_value.max.z = (float)box_src[5];
    RayCollision rl_value = GetRayCollisionBox(ray_value, box_value);
    RayCollision* rl_heap = (RayCollision*)malloc(sizeof(RayCollision));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetRayCollisionMesh(void* ray, void* mesh, float* transform, int32_t transform_len) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    if (transform_len < 16) return NULL;
    if (transform == NULL) return NULL;
    rl_disturb_float_t* transform_src = (rl_disturb_float_t*)(void*)transform;
    Matrix transform_value;
    memset(&transform_value, 0, sizeof(transform_value));
    transform_value.m0 = (float)transform_src[0];
    transform_value.m1 = (float)transform_src[1];
    transform_value.m2 = (float)transform_src[2];
    transform_value.m3 = (float)transform_src[3];
    transform_value.m4 = (float)transform_src[4];
    transform_value.m5 = (float)transform_src[5];
    transform_value.m6 = (float)transform_src[6];
    transform_value.m7 = (float)transform_src[7];
    transform_value.m8 = (float)transform_src[8];
    transform_value.m9 = (float)transform_src[9];
    transform_value.m10 = (float)transform_src[10];
    transform_value.m11 = (float)transform_src[11];
    transform_value.m12 = (float)transform_src[12];
    transform_value.m13 = (float)transform_src[13];
    transform_value.m14 = (float)transform_src[14];
    transform_value.m15 = (float)transform_src[15];
    RayCollision rl_value = GetRayCollisionMesh(ray_value, mesh_value, transform_value);
    RayCollision* rl_heap = (RayCollision*)malloc(sizeof(RayCollision));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetRayCollisionQuad(void* ray, float p1_x, float p1_y, float p1_z, float p2_x, float p2_y, float p2_z, float p3_x, float p3_y, float p3_z, float p4_x, float p4_y, float p4_z) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    Vector3 p1 = { p1_x, p1_y, p1_z };
    Vector3 p2 = { p2_x, p2_y, p2_z };
    Vector3 p3 = { p3_x, p3_y, p3_z };
    Vector3 p4 = { p4_x, p4_y, p4_z };
    RayCollision rl_value = GetRayCollisionQuad(ray_value, p1, p2, p3, p4);
    RayCollision* rl_heap = (RayCollision*)malloc(sizeof(RayCollision));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetRayCollisionSphere(void* ray, float center_x, float center_y, float center_z, float radius) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    Vector3 center = { center_x, center_y, center_z };
    RayCollision rl_value = GetRayCollisionSphere(ray_value, center, (float)radius);
    RayCollision* rl_heap = (RayCollision*)malloc(sizeof(RayCollision));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetRayCollisionTriangle(void* ray, float p1_x, float p1_y, float p1_z, float p2_x, float p2_y, float p2_z, float p3_x, float p3_y, float p3_z) {
    Ray ray_value;
    memset(&ray_value, 0, sizeof(ray_value));
    if (ray != NULL) {
        ray_value = *((Ray*)ray);
    }
    Vector3 p1 = { p1_x, p1_y, p1_z };
    Vector3 p2 = { p2_x, p2_y, p2_z };
    Vector3 p3 = { p3_x, p3_y, p3_z };
    RayCollision rl_value = GetRayCollisionTriangle(ray_value, p1, p2, p3);
    RayCollision* rl_heap = (RayCollision*)malloc(sizeof(RayCollision));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

int32_t rl2_GetRenderHeight(void) {
    return (int32_t)GetRenderHeight();
}

int32_t rl2_GetRenderWidth(void) {
    return (int32_t)GetRenderWidth();
}

int32_t rl2_GetScreenHeight(void) {
    return (int32_t)GetScreenHeight();
}

int32_t rl2_GetScreenToWorld2D(float position_x, float position_y, void* camera, float* ret_out, int32_t ret_out_len) {
    Vector2 position = { position_x, position_y };
    Camera2D camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera2D*)camera);
    }
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetScreenToWorld2D(position, camera_value);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

void* rl2_GetScreenToWorldRay(float position_x, float position_y, void* camera) {
    Vector2 position = { position_x, position_y };
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    Ray rl_value = GetScreenToWorldRay(position, camera_value);
    Ray* rl_heap = (Ray*)malloc(sizeof(Ray));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_GetScreenToWorldRayEx(float position_x, float position_y, void* camera, int32_t width, int32_t height) {
    Vector2 position = { position_x, position_y };
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    Ray rl_value = GetScreenToWorldRayEx(position, camera_value, (int)width, (int)height);
    Ray* rl_heap = (Ray*)malloc(sizeof(Ray));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

int32_t rl2_GetScreenWidth(void) {
    return (int32_t)GetScreenWidth();
}

int32_t rl2_GetShaderLocation(void* shader, char* uniformName) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    return (int32_t)GetShaderLocation(shader_value, (const char*)uniformName);
}

int32_t rl2_GetShaderLocationAttrib(void* shader, char* attribName) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    return (int32_t)GetShaderLocationAttrib(shader_value, (const char*)attribName);
}

void* rl2_GetShapesTexture(void) {
    Texture2D rl_value = GetShapesTexture();
    Texture2D* rl_heap = (Texture2D*)malloc(sizeof(Texture2D));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

int32_t rl2_GetShapesTextureRectangle(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 4) return 0;
    if (ret_out == NULL) return 0;
    Rectangle rl_value = GetShapesTextureRectangle();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    rl_out[2] = (rl_disturb_float_t)rl_value.width;
    rl_out[3] = (rl_disturb_float_t)rl_value.height;
    return 1;
}

int32_t rl2_GetSplinePointBasis(float p1_x, float p1_y, float p2_x, float p2_y, float p3_x, float p3_y, float p4_x, float p4_y, float t, float* ret_out, int32_t ret_out_len) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Vector2 p3 = { p3_x, p3_y };
    Vector2 p4 = { p4_x, p4_y };
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetSplinePointBasis(p1, p2, p3, p4, (float)t);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetSplinePointBezierCubic(float p1_x, float p1_y, float c2_x, float c2_y, float c3_x, float c3_y, float p4_x, float p4_y, float t, float* ret_out, int32_t ret_out_len) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 c2 = { c2_x, c2_y };
    Vector2 c3 = { c3_x, c3_y };
    Vector2 p4 = { p4_x, p4_y };
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetSplinePointBezierCubic(p1, c2, c3, p4, (float)t);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetSplinePointBezierQuad(float p1_x, float p1_y, float c2_x, float c2_y, float p3_x, float p3_y, float t, float* ret_out, int32_t ret_out_len) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 c2 = { c2_x, c2_y };
    Vector2 p3 = { p3_x, p3_y };
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetSplinePointBezierQuad(p1, c2, p3, (float)t);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetSplinePointCatmullRom(float p1_x, float p1_y, float p2_x, float p2_y, float p3_x, float p3_y, float p4_x, float p4_y, float t, float* ret_out, int32_t ret_out_len) {
    Vector2 p1 = { p1_x, p1_y };
    Vector2 p2 = { p2_x, p2_y };
    Vector2 p3 = { p3_x, p3_y };
    Vector2 p4 = { p4_x, p4_y };
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetSplinePointCatmullRom(p1, p2, p3, p4, (float)t);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetSplinePointLinear(float startPos_x, float startPos_y, float endPos_x, float endPos_y, float t, float* ret_out, int32_t ret_out_len) {
    Vector2 startPos = { startPos_x, startPos_y };
    Vector2 endPos = { endPos_x, endPos_y };
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetSplinePointLinear(startPos, endPos, (float)t);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

char* rl2_GetTextBetween(char* text, char* begin, char* end) {
    return (char*)GetTextBetween((const char*)text, (const char*)begin, (const char*)end);
}

float rl2_GetTime(void) {
    return (float)GetTime();
}

int32_t rl2_GetTouchPointCount(void) {
    return (int32_t)GetTouchPointCount();
}

int32_t rl2_GetTouchPointId(int32_t index) {
    return (int32_t)GetTouchPointId((int)index);
}

int32_t rl2_GetTouchPosition(int32_t index, float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetTouchPosition((int)index);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetTouchX(void) {
    return (int32_t)GetTouchX();
}

int32_t rl2_GetTouchY(void) {
    return (int32_t)GetTouchY();
}

void* rl2_GetWindowHandle(void) {
    return (void*)GetWindowHandle();
}

int32_t rl2_GetWindowPosition(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetWindowPosition();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetWindowScaleDPI(float* ret_out, int32_t ret_out_len) {
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetWindowScaleDPI();
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

char* rl2_GetWorkingDirectory(void) {
    return (char*)GetWorkingDirectory();
}

int32_t rl2_GetWorldToScreen(float position_x, float position_y, float position_z, void* camera, float* ret_out, int32_t ret_out_len) {
    Vector3 position = { position_x, position_y, position_z };
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetWorldToScreen(position, camera_value);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetWorldToScreen2D(float position_x, float position_y, void* camera, float* ret_out, int32_t ret_out_len) {
    Vector2 position = { position_x, position_y };
    Camera2D camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera2D*)camera);
    }
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetWorldToScreen2D(position, camera_value);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

int32_t rl2_GetWorldToScreenEx(float position_x, float position_y, float position_z, void* camera, int32_t width, int32_t height, float* ret_out, int32_t ret_out_len) {
    Vector3 position = { position_x, position_y, position_z };
    Camera camera_value;
    memset(&camera_value, 0, sizeof(camera_value));
    if (camera != NULL) {
        camera_value = *((Camera*)camera);
    }
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = GetWorldToScreenEx(position, camera_value, (int)width, (int)height);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

void* rl2_HideCursor(void) {
    HideCursor();
    return NULL;
}

void* rl2_ImageAlphaClear(void* image, int32_t color_rgba, float threshold) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageAlphaClear((Image*)image, color, (float)threshold);
    return NULL;
}

void* rl2_ImageAlphaCrop(void* image, float threshold) {
    ImageAlphaCrop((Image*)image, (float)threshold);
    return NULL;
}

void* rl2_ImageAlphaMask(void* image, void* alphaMask) {
    Image alphaMask_value;
    memset(&alphaMask_value, 0, sizeof(alphaMask_value));
    if (alphaMask != NULL) {
        alphaMask_value = *((Image*)alphaMask);
    }
    ImageAlphaMask((Image*)image, alphaMask_value);
    return NULL;
}

void* rl2_ImageAlphaPremultiply(void* image) {
    ImageAlphaPremultiply((Image*)image);
    return NULL;
}

void* rl2_ImageBlurGaussian(void* image, int32_t blurSize) {
    ImageBlurGaussian((Image*)image, (int)blurSize);
    return NULL;
}

void* rl2_ImageClearBackground(void* dst, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageClearBackground((Image*)dst, color);
    return NULL;
}

void* rl2_ImageColorBrightness(void* image, int32_t brightness) {
    ImageColorBrightness((Image*)image, (int)brightness);
    return NULL;
}

void* rl2_ImageColorContrast(void* image, float contrast) {
    ImageColorContrast((Image*)image, (float)contrast);
    return NULL;
}

void* rl2_ImageColorGrayscale(void* image) {
    ImageColorGrayscale((Image*)image);
    return NULL;
}

void* rl2_ImageColorInvert(void* image) {
    ImageColorInvert((Image*)image);
    return NULL;
}

void* rl2_ImageColorReplace(void* image, int32_t color_rgba, int32_t replace_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    Color replace = rl_color_from_rgba_i32(replace_rgba);
    ImageColorReplace((Image*)image, color, replace);
    return NULL;
}

void* rl2_ImageColorTint(void* image, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageColorTint((Image*)image, color);
    return NULL;
}

void* rl2_ImageCopy(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    Image rl_value = ImageCopy(image_value);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_ImageCrop(void* image, float crop_x, float crop_y, float crop_w, float crop_h) {
    Rectangle crop = { crop_x, crop_y, crop_w, crop_h };
    ImageCrop((Image*)image, crop);
    return NULL;
}

void* rl2_ImageDither(void* image, int32_t rBpp, int32_t gBpp, int32_t bBpp, int32_t aBpp) {
    ImageDither((Image*)image, (int)rBpp, (int)gBpp, (int)bBpp, (int)aBpp);
    return NULL;
}

void* rl2_ImageDraw(void* dst, void* src, float srcRec_x, float srcRec_y, float srcRec_w, float srcRec_h, float dstRec_x, float dstRec_y, float dstRec_w, float dstRec_h, int32_t tint_rgba) {
    Image src_value;
    memset(&src_value, 0, sizeof(src_value));
    if (src != NULL) {
        src_value = *((Image*)src);
    }
    Rectangle srcRec = { srcRec_x, srcRec_y, srcRec_w, srcRec_h };
    Rectangle dstRec = { dstRec_x, dstRec_y, dstRec_w, dstRec_h };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    ImageDraw((Image*)dst, src_value, srcRec, dstRec, tint);
    return NULL;
}

void* rl2_ImageDrawCircle(void* dst, int32_t centerX, int32_t centerY, int32_t radius, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawCircle((Image*)dst, (int)centerX, (int)centerY, (int)radius, color);
    return NULL;
}

void* rl2_ImageDrawCircleLines(void* dst, int32_t centerX, int32_t centerY, int32_t radius, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawCircleLines((Image*)dst, (int)centerX, (int)centerY, (int)radius, color);
    return NULL;
}

void* rl2_ImageDrawCircleLinesV(void* dst, float center_x, float center_y, int32_t radius, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawCircleLinesV((Image*)dst, center, (int)radius, color);
    return NULL;
}

void* rl2_ImageDrawCircleV(void* dst, float center_x, float center_y, int32_t radius, int32_t color_rgba) {
    Vector2 center = { center_x, center_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawCircleV((Image*)dst, center, (int)radius, color);
    return NULL;
}

void* rl2_ImageDrawLine(void* dst, int32_t startPosX, int32_t startPosY, int32_t endPosX, int32_t endPosY, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawLine((Image*)dst, (int)startPosX, (int)startPosY, (int)endPosX, (int)endPosY, color);
    return NULL;
}

void* rl2_ImageDrawLineEx(void* dst, float start_x, float start_y, float end_x, float end_y, int32_t thick, int32_t color_rgba) {
    Vector2 start = { start_x, start_y };
    Vector2 end = { end_x, end_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawLineEx((Image*)dst, start, end, (int)thick, color);
    return NULL;
}

void* rl2_ImageDrawLineV(void* dst, float start_x, float start_y, float end_x, float end_y, int32_t color_rgba) {
    Vector2 start = { start_x, start_y };
    Vector2 end = { end_x, end_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawLineV((Image*)dst, start, end, color);
    return NULL;
}

void* rl2_ImageDrawPixel(void* dst, int32_t posX, int32_t posY, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawPixel((Image*)dst, (int)posX, (int)posY, color);
    return NULL;
}

void* rl2_ImageDrawPixelV(void* dst, float position_x, float position_y, int32_t color_rgba) {
    Vector2 position = { position_x, position_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawPixelV((Image*)dst, position, color);
    return NULL;
}

void* rl2_ImageDrawRectangle(void* dst, int32_t posX, int32_t posY, int32_t width, int32_t height, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawRectangle((Image*)dst, (int)posX, (int)posY, (int)width, (int)height, color);
    return NULL;
}

void* rl2_ImageDrawRectangleLines(void* dst, float rec_x, float rec_y, float rec_w, float rec_h, int32_t thick, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawRectangleLines((Image*)dst, rec, (int)thick, color);
    return NULL;
}

void* rl2_ImageDrawRectangleRec(void* dst, float rec_x, float rec_y, float rec_w, float rec_h, int32_t color_rgba) {
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawRectangleRec((Image*)dst, rec, color);
    return NULL;
}

void* rl2_ImageDrawRectangleV(void* dst, float position_x, float position_y, float size_x, float size_y, int32_t color_rgba) {
    Vector2 position = { position_x, position_y };
    Vector2 size = { size_x, size_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawRectangleV((Image*)dst, position, size, color);
    return NULL;
}

void* rl2_ImageDrawText(void* dst, char* text, int32_t posX, int32_t posY, int32_t fontSize, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawText((Image*)dst, (const char*)text, (int)posX, (int)posY, (int)fontSize, color);
    return NULL;
}

void* rl2_ImageDrawTextEx(void* dst, void* font, char* text, float position_x, float position_y, float fontSize, float spacing, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Vector2 position = { position_x, position_y };
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    ImageDrawTextEx((Image*)dst, font_value, (const char*)text, position, (float)fontSize, (float)spacing, tint);
    return NULL;
}

void* rl2_ImageDrawTriangle(void* dst, float v1_x, float v1_y, float v2_x, float v2_y, float v3_x, float v3_y, int32_t color_rgba) {
    Vector2 v1 = { v1_x, v1_y };
    Vector2 v2 = { v2_x, v2_y };
    Vector2 v3 = { v3_x, v3_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawTriangle((Image*)dst, v1, v2, v3, color);
    return NULL;
}

void* rl2_ImageDrawTriangleEx(void* dst, float v1_x, float v1_y, float v2_x, float v2_y, float v3_x, float v3_y, int32_t c1_rgba, int32_t c2_rgba, int32_t c3_rgba) {
    Vector2 v1 = { v1_x, v1_y };
    Vector2 v2 = { v2_x, v2_y };
    Vector2 v3 = { v3_x, v3_y };
    Color c1 = rl_color_from_rgba_i32(c1_rgba);
    Color c2 = rl_color_from_rgba_i32(c2_rgba);
    Color c3 = rl_color_from_rgba_i32(c3_rgba);
    ImageDrawTriangleEx((Image*)dst, v1, v2, v3, c1, c2, c3);
    return NULL;
}

void* rl2_ImageDrawTriangleFan(void* dst, float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    ImageDrawTriangleFan((Image*)dst, (const Vector2*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_ImageDrawTriangleLines(void* dst, float v1_x, float v1_y, float v2_x, float v2_y, float v3_x, float v3_y, int32_t color_rgba) {
    Vector2 v1 = { v1_x, v1_y };
    Vector2 v2 = { v2_x, v2_y };
    Vector2 v3 = { v3_x, v3_y };
    Color color = rl_color_from_rgba_i32(color_rgba);
    ImageDrawTriangleLines((Image*)dst, v1, v2, v3, color);
    return NULL;
}

void* rl2_ImageDrawTriangleStrip(void* dst, float* points, int32_t pointCount, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    if (pointCount < 0) return NULL;
    if (pointCount > 0 && points == NULL) return NULL;
    ImageDrawTriangleStrip((Image*)dst, (const Vector2*)points, (int)pointCount, color);
    return NULL;
}

void* rl2_ImageFlipHorizontal(void* image) {
    ImageFlipHorizontal((Image*)image);
    return NULL;
}

void* rl2_ImageFlipVertical(void* image) {
    ImageFlipVertical((Image*)image);
    return NULL;
}

void* rl2_ImageFormat(void* image, int32_t newFormat) {
    ImageFormat((Image*)image, (int)newFormat);
    return NULL;
}

void* rl2_ImageFromChannel(void* image, int32_t selectedChannel) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    Image rl_value = ImageFromChannel(image_value, (int)selectedChannel);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_ImageFromImage(void* image, float rec_x, float rec_y, float rec_w, float rec_h) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    Image rl_value = ImageFromImage(image_value, rec);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_ImageKernelConvolution(void* image, float* kernel, int32_t kernelSize) {
    if (kernelSize < 0) return NULL;
    if (kernelSize > 0 && kernel == NULL) return NULL;
    ImageKernelConvolution((Image*)image, (const float*)kernel, (int)kernelSize);
    return NULL;
}

void* rl2_ImageMipmaps(void* image) {
    ImageMipmaps((Image*)image);
    return NULL;
}

void* rl2_ImageResize(void* image, int32_t newWidth, int32_t newHeight) {
    ImageResize((Image*)image, (int)newWidth, (int)newHeight);
    return NULL;
}

void* rl2_ImageResizeCanvas(void* image, int32_t newWidth, int32_t newHeight, int32_t offsetX, int32_t offsetY, int32_t fill_rgba) {
    Color fill = rl_color_from_rgba_i32(fill_rgba);
    ImageResizeCanvas((Image*)image, (int)newWidth, (int)newHeight, (int)offsetX, (int)offsetY, fill);
    return NULL;
}

void* rl2_ImageResizeNN(void* image, int32_t newWidth, int32_t newHeight) {
    ImageResizeNN((Image*)image, (int)newWidth, (int)newHeight);
    return NULL;
}

void* rl2_ImageRotate(void* image, int32_t degrees) {
    ImageRotate((Image*)image, (int)degrees);
    return NULL;
}

void* rl2_ImageRotateCCW(void* image) {
    ImageRotateCCW((Image*)image);
    return NULL;
}

void* rl2_ImageRotateCW(void* image) {
    ImageRotateCW((Image*)image);
    return NULL;
}

void* rl2_ImageText(char* text, int32_t fontSize, int32_t color_rgba) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    Image rl_value = ImageText((const char*)text, (int)fontSize, color);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_ImageTextEx(void* font, char* text, float fontSize, float spacing, int32_t tint_rgba) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    Color tint = rl_color_from_rgba_i32(tint_rgba);
    Image rl_value = ImageTextEx(font_value, (const char*)text, (float)fontSize, (float)spacing, tint);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_ImageToPOT(void* image, int32_t fill_rgba) {
    Color fill = rl_color_from_rgba_i32(fill_rgba);
    ImageToPOT((Image*)image, fill);
    return NULL;
}

void* rl2_InitAudioDevice(void) {
    InitAudioDevice();
    return NULL;
}

void* rl2_InitWindow(int32_t width, int32_t height, char* title) {
    InitWindow((int)width, (int)height, (const char*)title);
    return NULL;
}

int32_t rl2_IsAudioDeviceReady(void) {
    return IsAudioDeviceReady() ? 1 : 0;
}

int32_t rl2_IsAudioStreamPlaying(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    return IsAudioStreamPlaying(stream_value) ? 1 : 0;
}

int32_t rl2_IsAudioStreamProcessed(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    return IsAudioStreamProcessed(stream_value) ? 1 : 0;
}

int32_t rl2_IsAudioStreamValid(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    return IsAudioStreamValid(stream_value) ? 1 : 0;
}

int32_t rl2_IsCursorHidden(void) {
    return IsCursorHidden() ? 1 : 0;
}

int32_t rl2_IsCursorOnScreen(void) {
    return IsCursorOnScreen() ? 1 : 0;
}

int32_t rl2_IsFileDropped(void) {
    return IsFileDropped() ? 1 : 0;
}

int32_t rl2_IsFileExtension(char* fileName, char* ext) {
    return IsFileExtension((const char*)fileName, (const char*)ext) ? 1 : 0;
}

int32_t rl2_IsFileNameValid(char* fileName) {
    return IsFileNameValid((const char*)fileName) ? 1 : 0;
}

int32_t rl2_IsFontValid(void* font) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    return IsFontValid(font_value) ? 1 : 0;
}

int32_t rl2_IsGamepadAvailable(int32_t gamepad) {
    return IsGamepadAvailable((int)gamepad) ? 1 : 0;
}

int32_t rl2_IsGamepadButtonDown(int32_t gamepad, int32_t button) {
    return IsGamepadButtonDown((int)gamepad, (int)button) ? 1 : 0;
}

int32_t rl2_IsGamepadButtonPressed(int32_t gamepad, int32_t button) {
    return IsGamepadButtonPressed((int)gamepad, (int)button) ? 1 : 0;
}

int32_t rl2_IsGamepadButtonReleased(int32_t gamepad, int32_t button) {
    return IsGamepadButtonReleased((int)gamepad, (int)button) ? 1 : 0;
}

int32_t rl2_IsGamepadButtonUp(int32_t gamepad, int32_t button) {
    return IsGamepadButtonUp((int)gamepad, (int)button) ? 1 : 0;
}

int32_t rl2_IsGestureDetected(int32_t gesture) {
    return IsGestureDetected((unsigned int)gesture) ? 1 : 0;
}

int32_t rl2_IsImageValid(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    return IsImageValid(image_value) ? 1 : 0;
}

int32_t rl2_IsKeyDown(int32_t key) {
    return IsKeyDown((int)key) ? 1 : 0;
}

int32_t rl2_IsKeyPressed(int32_t key) {
    return IsKeyPressed((int)key) ? 1 : 0;
}

int32_t rl2_IsKeyPressedRepeat(int32_t key) {
    return IsKeyPressedRepeat((int)key) ? 1 : 0;
}

int32_t rl2_IsKeyReleased(int32_t key) {
    return IsKeyReleased((int)key) ? 1 : 0;
}

int32_t rl2_IsKeyUp(int32_t key) {
    return IsKeyUp((int)key) ? 1 : 0;
}

int32_t rl2_IsMaterialValid(void* material) {
    Material material_value;
    memset(&material_value, 0, sizeof(material_value));
    if (material != NULL) {
        material_value = *((Material*)material);
    }
    return IsMaterialValid(material_value) ? 1 : 0;
}

int32_t rl2_IsModelAnimationValid(void* model, void* anim) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    ModelAnimation anim_value;
    memset(&anim_value, 0, sizeof(anim_value));
    if (anim != NULL) {
        anim_value = *((ModelAnimation*)anim);
    }
    return IsModelAnimationValid(model_value, anim_value) ? 1 : 0;
}

int32_t rl2_IsModelValid(void* model) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    return IsModelValid(model_value) ? 1 : 0;
}

int32_t rl2_IsMouseButtonDown(int32_t button) {
    return IsMouseButtonDown((int)button) ? 1 : 0;
}

int32_t rl2_IsMouseButtonPressed(int32_t button) {
    return IsMouseButtonPressed((int)button) ? 1 : 0;
}

int32_t rl2_IsMouseButtonReleased(int32_t button) {
    return IsMouseButtonReleased((int)button) ? 1 : 0;
}

int32_t rl2_IsMouseButtonUp(int32_t button) {
    return IsMouseButtonUp((int)button) ? 1 : 0;
}

int32_t rl2_IsMusicStreamPlaying(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    return IsMusicStreamPlaying(music_value) ? 1 : 0;
}

int32_t rl2_IsMusicValid(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    return IsMusicValid(music_value) ? 1 : 0;
}

int32_t rl2_IsPathFile(char* path) {
    return IsPathFile((const char*)path) ? 1 : 0;
}

int32_t rl2_IsRenderTextureValid(void* target) {
    RenderTexture2D target_value;
    memset(&target_value, 0, sizeof(target_value));
    if (target != NULL) {
        target_value = *((RenderTexture2D*)target);
    }
    return IsRenderTextureValid(target_value) ? 1 : 0;
}

int32_t rl2_IsShaderValid(void* shader) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    return IsShaderValid(shader_value) ? 1 : 0;
}

int32_t rl2_IsSoundPlaying(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    return IsSoundPlaying(sound_value) ? 1 : 0;
}

int32_t rl2_IsSoundValid(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    return IsSoundValid(sound_value) ? 1 : 0;
}

int32_t rl2_IsTextureValid(void* texture) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    return IsTextureValid(texture_value) ? 1 : 0;
}

int32_t rl2_IsWaveValid(void* wave) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    return IsWaveValid(wave_value) ? 1 : 0;
}

int32_t rl2_IsWindowFocused(void) {
    return IsWindowFocused() ? 1 : 0;
}

int32_t rl2_IsWindowFullscreen(void) {
    return IsWindowFullscreen() ? 1 : 0;
}

int32_t rl2_IsWindowHidden(void) {
    return IsWindowHidden() ? 1 : 0;
}

int32_t rl2_IsWindowMaximized(void) {
    return IsWindowMaximized() ? 1 : 0;
}

int32_t rl2_IsWindowMinimized(void) {
    return IsWindowMinimized() ? 1 : 0;
}

int32_t rl2_IsWindowReady(void) {
    return IsWindowReady() ? 1 : 0;
}

int32_t rl2_IsWindowResized(void) {
    return IsWindowResized() ? 1 : 0;
}

int32_t rl2_IsWindowState(int32_t flag) {
    return IsWindowState((unsigned int)flag) ? 1 : 0;
}

void* rl2_LoadAudioStream(int32_t sampleRate, int32_t sampleSize, int32_t channels) {
    AudioStream rl_value = LoadAudioStream((unsigned int)sampleRate, (unsigned int)sampleSize, (unsigned int)channels);
    AudioStream* rl_heap = (AudioStream*)malloc(sizeof(AudioStream));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadAutomationEventList(char* fileName) {
    AutomationEventList rl_value = LoadAutomationEventList((const char*)fileName);
    AutomationEventList* rl_heap = (AutomationEventList*)malloc(sizeof(AutomationEventList));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadCodepoints(char* text, int32_t* count, int32_t count_len) {
    if (count_len < 1) return NULL;
    if (count == NULL) return NULL;
    return (void*)LoadCodepoints((const char*)text, (int*)count);
}

void* rl2_LoadDirectoryFiles(char* dirPath) {
    FilePathList rl_value = LoadDirectoryFiles((const char*)dirPath);
    FilePathList* rl_heap = (FilePathList*)malloc(sizeof(FilePathList));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadDirectoryFilesEx(char* basePath, char* filter, int32_t scanSubdirs) {
    FilePathList rl_value = LoadDirectoryFilesEx((const char*)basePath, (const char*)filter, (bool)scanSubdirs);
    FilePathList* rl_heap = (FilePathList*)malloc(sizeof(FilePathList));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadDroppedFiles(void) {
    FilePathList rl_value = LoadDroppedFiles();
    FilePathList* rl_heap = (FilePathList*)malloc(sizeof(FilePathList));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadFileData(char* fileName, int32_t* dataSize, int32_t dataSize_len) {
    if (dataSize_len < 1) return NULL;
    if (dataSize == NULL) return NULL;
    return (void*)LoadFileData((const char*)fileName, (int*)dataSize);
}

char* rl2_LoadFileText(char* fileName) {
    return (char*)LoadFileText((const char*)fileName);
}

void* rl2_LoadFont(char* fileName) {
    Font rl_value = LoadFont((const char*)fileName);
    Font* rl_heap = (Font*)malloc(sizeof(Font));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadFontData(int32_t* fileData, int32_t dataSize, int32_t fontSize, int32_t* codepoints, int32_t codepointCount, int32_t type, int32_t* glyphCount) {
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && codepoints == NULL) return NULL;
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && fileData == NULL) return NULL;
    return (void*)LoadFontData((const unsigned char*)fileData, (int)dataSize, (int)fontSize, (const int*)codepoints, (int)codepointCount, (int)type, (int*)glyphCount);
}

void* rl2_LoadFontEx(char* fileName, int32_t fontSize, int32_t* codepoints, int32_t codepointCount) {
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && codepoints == NULL) return NULL;
    Font rl_value = LoadFontEx((const char*)fileName, (int)fontSize, (const int*)codepoints, (int)codepointCount);
    Font* rl_heap = (Font*)malloc(sizeof(Font));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadFontFromImage(void* image, int32_t key_rgba, int32_t firstChar) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    Color key = rl_color_from_rgba_i32(key_rgba);
    Font rl_value = LoadFontFromImage(image_value, key, (int)firstChar);
    Font* rl_heap = (Font*)malloc(sizeof(Font));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadFontFromMemory(char* fileType, int32_t* fileData, int32_t dataSize, int32_t fontSize, int32_t* codepoints, int32_t codepointCount) {
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && codepoints == NULL) return NULL;
    if (codepointCount < 0) return NULL;
    if (codepointCount > 0 && fileData == NULL) return NULL;
    Font rl_value = LoadFontFromMemory((const char*)fileType, (const unsigned char*)fileData, (int)dataSize, (int)fontSize, (const int*)codepoints, (int)codepointCount);
    Font* rl_heap = (Font*)malloc(sizeof(Font));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImage(char* fileName) {
    Image rl_value = LoadImage((const char*)fileName);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImageAnim(char* fileName, int32_t* frames, int32_t frames_len) {
    if (frames_len < 1) return NULL;
    if (frames == NULL) return NULL;
    Image rl_value = LoadImageAnim((const char*)fileName, (int*)frames);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImageAnimFromMemory(char* fileType, int32_t* fileData, int32_t dataSize, int32_t* frames) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && fileData == NULL) return NULL;
    Image rl_value = LoadImageAnimFromMemory((const char*)fileType, (const unsigned char*)fileData, (int)dataSize, (int*)frames);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImageColors(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    return (void*)LoadImageColors(image_value);
}

void* rl2_LoadImageFromMemory(char* fileType, int32_t* fileData, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && fileData == NULL) return NULL;
    Image rl_value = LoadImageFromMemory((const char*)fileType, (const unsigned char*)fileData, (int)dataSize);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImageFromScreen(void) {
    Image rl_value = LoadImageFromScreen();
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImageFromTexture(void* texture) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Image rl_value = LoadImageFromTexture(texture_value);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadImagePalette(void* image, int32_t maxPaletteSize, int32_t* colorCount) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    return (void*)LoadImagePalette(image_value, (int)maxPaletteSize, (int*)colorCount);
}

void* rl2_LoadImageRaw(char* fileName, int32_t width, int32_t height, int32_t format, int32_t headerSize) {
    Image rl_value = LoadImageRaw((const char*)fileName, (int)width, (int)height, (int)format, (int)headerSize);
    Image* rl_heap = (Image*)malloc(sizeof(Image));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadMaterialDefault(void) {
    Material rl_value = LoadMaterialDefault();
    Material* rl_heap = (Material*)malloc(sizeof(Material));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadMaterials(char* fileName, int32_t* materialCount, int32_t materialCount_len) {
    if (materialCount_len < 1) return NULL;
    if (materialCount == NULL) return NULL;
    return (void*)LoadMaterials((const char*)fileName, (int*)materialCount);
}

void* rl2_LoadModel(char* fileName) {
    Model rl_value = LoadModel((const char*)fileName);
    Model* rl_heap = (Model*)malloc(sizeof(Model));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadModelAnimations(char* fileName, int32_t* animCount, int32_t animCount_len) {
    if (animCount_len < 1) return NULL;
    if (animCount == NULL) return NULL;
    return (void*)LoadModelAnimations((const char*)fileName, (int*)animCount);
}

void* rl2_LoadModelFromMesh(void* mesh) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    Model rl_value = LoadModelFromMesh(mesh_value);
    Model* rl_heap = (Model*)malloc(sizeof(Model));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadMusicStream(char* fileName) {
    Music rl_value = LoadMusicStream((const char*)fileName);
    Music* rl_heap = (Music*)malloc(sizeof(Music));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadMusicStreamFromMemory(char* fileType, int32_t* data, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && data == NULL) return NULL;
    Music rl_value = LoadMusicStreamFromMemory((const char*)fileType, (const unsigned char*)data, (int)dataSize);
    Music* rl_heap = (Music*)malloc(sizeof(Music));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadRandomSequence(int32_t count, int32_t min, int32_t max) {
    return (void*)LoadRandomSequence((unsigned int)count, (int)min, (int)max);
}

void* rl2_LoadRenderTexture(int32_t width, int32_t height) {
    RenderTexture2D rl_value = LoadRenderTexture((int)width, (int)height);
    RenderTexture2D* rl_heap = (RenderTexture2D*)malloc(sizeof(RenderTexture2D));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadShader(char* vsFileName, char* fsFileName) {
    Shader rl_value = LoadShader((const char*)vsFileName, (const char*)fsFileName);
    Shader* rl_heap = (Shader*)malloc(sizeof(Shader));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadShaderFromMemory(char* vsCode, char* fsCode) {
    Shader rl_value = LoadShaderFromMemory((const char*)vsCode, (const char*)fsCode);
    Shader* rl_heap = (Shader*)malloc(sizeof(Shader));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadSound(char* fileName) {
    Sound rl_value = LoadSound((const char*)fileName);
    Sound* rl_heap = (Sound*)malloc(sizeof(Sound));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadSoundAlias(void* source) {
    Sound source_value;
    memset(&source_value, 0, sizeof(source_value));
    if (source != NULL) {
        source_value = *((Sound*)source);
    }
    Sound rl_value = LoadSoundAlias(source_value);
    Sound* rl_heap = (Sound*)malloc(sizeof(Sound));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadSoundFromWave(void* wave) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    Sound rl_value = LoadSoundFromWave(wave_value);
    Sound* rl_heap = (Sound*)malloc(sizeof(Sound));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

char* rl2_LoadTextLines(char* text, int32_t* count, int32_t count_len) {
    if (count_len < 1) return NULL;
    if (count == NULL) return NULL;
    return (char*)LoadTextLines((const char*)text, (int*)count);
}

void* rl2_LoadTexture(char* fileName) {
    Texture2D rl_value = LoadTexture((const char*)fileName);
    Texture2D* rl_heap = (Texture2D*)malloc(sizeof(Texture2D));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadTextureCubemap(void* image, int32_t layout) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    TextureCubemap rl_value = LoadTextureCubemap(image_value, (int)layout);
    TextureCubemap* rl_heap = (TextureCubemap*)malloc(sizeof(TextureCubemap));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadTextureFromImage(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    Texture2D rl_value = LoadTextureFromImage(image_value);
    Texture2D* rl_heap = (Texture2D*)malloc(sizeof(Texture2D));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

char* rl2_LoadUTF8(int32_t* codepoints, int32_t length) {
    if (length < 0) return NULL;
    if (length > 0 && codepoints == NULL) return NULL;
    return (char*)LoadUTF8((const int*)codepoints, (int)length);
}

void* rl2_LoadVrStereoConfig(void* device) {
    VrDeviceInfo device_value;
    memset(&device_value, 0, sizeof(device_value));
    if (device != NULL) {
        device_value = *((VrDeviceInfo*)device);
    }
    VrStereoConfig rl_value = LoadVrStereoConfig(device_value);
    VrStereoConfig* rl_heap = (VrStereoConfig*)malloc(sizeof(VrStereoConfig));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadWave(char* fileName) {
    Wave rl_value = LoadWave((const char*)fileName);
    Wave* rl_heap = (Wave*)malloc(sizeof(Wave));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadWaveFromMemory(char* fileType, int32_t* fileData, int32_t dataSize) {
    if (dataSize < 0) return NULL;
    if (dataSize > 0 && fileData == NULL) return NULL;
    Wave rl_value = LoadWaveFromMemory((const char*)fileType, (const unsigned char*)fileData, (int)dataSize);
    Wave* rl_heap = (Wave*)malloc(sizeof(Wave));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_LoadWaveSamples(void* wave) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    return (void*)LoadWaveSamples(wave_value);
}

int32_t rl2_MakeDirectory(char* dirPath) {
    return (int32_t)MakeDirectory((const char*)dirPath);
}

void* rl2_MaximizeWindow(void) {
    MaximizeWindow();
    return NULL;
}

int32_t rl2_MeasureText(char* text, int32_t fontSize) {
    return (int32_t)MeasureText((const char*)text, (int)fontSize);
}

int32_t rl2_MeasureTextEx(void* font, char* text, float fontSize, float spacing, float* ret_out, int32_t ret_out_len) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    if (ret_out_len < 2) return 0;
    if (ret_out == NULL) return 0;
    Vector2 rl_value = MeasureTextEx(font_value, (const char*)text, (float)fontSize, (float)spacing);
    rl_disturb_float_t* rl_out = (rl_disturb_float_t*)(void*)ret_out;
    rl_out[0] = (rl_disturb_float_t)rl_value.x;
    rl_out[1] = (rl_disturb_float_t)rl_value.y;
    return 1;
}

void* rl2_MemAlloc(int32_t size) {
    return (void*)MemAlloc((unsigned int)size);
}

void* rl2_MemFree(void* ptr) {
    MemFree((void*)ptr);
    return NULL;
}

void* rl2_MemRealloc(void* ptr, int32_t size) {
    return (void*)MemRealloc((void*)ptr, (unsigned int)size);
}

void* rl2_MinimizeWindow(void) {
    MinimizeWindow();
    return NULL;
}

void* rl2_OpenURL(char* url) {
    OpenURL((const char*)url);
    return NULL;
}

void* rl2_PauseAudioStream(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    PauseAudioStream(stream_value);
    return NULL;
}

void* rl2_PauseMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    PauseMusicStream(music_value);
    return NULL;
}

void* rl2_PauseSound(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    PauseSound(sound_value);
    return NULL;
}

void* rl2_PlayAudioStream(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    PlayAudioStream(stream_value);
    return NULL;
}

void* rl2_PlayAutomationEvent(void* event) {
    AutomationEvent event_value;
    memset(&event_value, 0, sizeof(event_value));
    if (event != NULL) {
        event_value = *((AutomationEvent*)event);
    }
    PlayAutomationEvent(event_value);
    return NULL;
}

void* rl2_PlayMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    PlayMusicStream(music_value);
    return NULL;
}

void* rl2_PlaySound(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    PlaySound(sound_value);
    return NULL;
}

void* rl2_PollInputEvents(void) {
    PollInputEvents();
    return NULL;
}

void* rl2_RestoreWindow(void) {
    RestoreWindow();
    return NULL;
}

void* rl2_ResumeAudioStream(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    ResumeAudioStream(stream_value);
    return NULL;
}

void* rl2_ResumeMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    ResumeMusicStream(music_value);
    return NULL;
}

void* rl2_ResumeSound(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    ResumeSound(sound_value);
    return NULL;
}

int32_t rl2_SaveFileData(char* fileName, void* data, int32_t dataSize) {
    return SaveFileData((const char*)fileName, (void*)data, (int)dataSize) ? 1 : 0;
}

int32_t rl2_SaveFileText(char* fileName, char* text) {
    return SaveFileText((const char*)fileName, (const char*)text) ? 1 : 0;
}

void* rl2_SeekMusicStream(void* music, float position) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    SeekMusicStream(music_value, (float)position);
    return NULL;
}

void* rl2_SetAudioStreamBufferSizeDefault(int32_t size) {
    SetAudioStreamBufferSizeDefault((int)size);
    return NULL;
}

void* rl2_SetAudioStreamPan(void* stream, float pan) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    SetAudioStreamPan(stream_value, (float)pan);
    return NULL;
}

void* rl2_SetAudioStreamPitch(void* stream, float pitch) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    SetAudioStreamPitch(stream_value, (float)pitch);
    return NULL;
}

void* rl2_SetAudioStreamVolume(void* stream, float volume) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    SetAudioStreamVolume(stream_value, (float)volume);
    return NULL;
}

void* rl2_SetAutomationEventBaseFrame(int32_t frame) {
    SetAutomationEventBaseFrame((int)frame);
    return NULL;
}

void* rl2_SetAutomationEventList(void* list) {
    SetAutomationEventList((AutomationEventList*)list);
    return NULL;
}

void* rl2_SetClipboardText(char* text) {
    SetClipboardText((const char*)text);
    return NULL;
}

void* rl2_SetConfigFlags(int32_t flags) {
    SetConfigFlags((unsigned int)flags);
    return NULL;
}

void* rl2_SetExitKey(int32_t key) {
    SetExitKey((int)key);
    return NULL;
}

int32_t rl2_SetGamepadMappings(char* mappings) {
    return (int32_t)SetGamepadMappings((const char*)mappings);
}

void* rl2_SetGamepadVibration(int32_t gamepad, float leftMotor, float rightMotor, float duration) {
    SetGamepadVibration((int)gamepad, (float)leftMotor, (float)rightMotor, (float)duration);
    return NULL;
}

void* rl2_SetGesturesEnabled(int32_t flags) {
    SetGesturesEnabled((unsigned int)flags);
    return NULL;
}

void* rl2_SetMasterVolume(float volume) {
    SetMasterVolume((float)volume);
    return NULL;
}

void* rl2_SetMaterialTexture(void* material, int32_t mapType, void* texture) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    SetMaterialTexture((Material*)material, (int)mapType, texture_value);
    return NULL;
}

void* rl2_SetModelMeshMaterial(void* model, int32_t meshId, int32_t materialId) {
    SetModelMeshMaterial((Model*)model, (int)meshId, (int)materialId);
    return NULL;
}

void* rl2_SetMouseCursor(int32_t cursor) {
    SetMouseCursor((int)cursor);
    return NULL;
}

void* rl2_SetMouseOffset(int32_t offsetX, int32_t offsetY) {
    SetMouseOffset((int)offsetX, (int)offsetY);
    return NULL;
}

void* rl2_SetMousePosition(int32_t x, int32_t y) {
    SetMousePosition((int)x, (int)y);
    return NULL;
}

void* rl2_SetMouseScale(float scaleX, float scaleY) {
    SetMouseScale((float)scaleX, (float)scaleY);
    return NULL;
}

void* rl2_SetMusicPan(void* music, float pan) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    SetMusicPan(music_value, (float)pan);
    return NULL;
}

void* rl2_SetMusicPitch(void* music, float pitch) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    SetMusicPitch(music_value, (float)pitch);
    return NULL;
}

void* rl2_SetMusicVolume(void* music, float volume) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    SetMusicVolume(music_value, (float)volume);
    return NULL;
}

void* rl2_SetPixelColor(void* dstPtr, int32_t color_rgba, int32_t format) {
    Color color = rl_color_from_rgba_i32(color_rgba);
    SetPixelColor((void*)dstPtr, color, (int)format);
    return NULL;
}

void* rl2_SetRandomSeed(int32_t seed) {
    SetRandomSeed((unsigned int)seed);
    return NULL;
}

void* rl2_SetShaderValue(void* shader, int32_t locIndex, void* value, int32_t uniformType) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    SetShaderValue(shader_value, (int)locIndex, (const void*)value, (int)uniformType);
    return NULL;
}

void* rl2_SetShaderValueMatrix(void* shader, int32_t locIndex, float* mat, int32_t mat_len) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    if (mat_len < 16) return NULL;
    if (mat == NULL) return NULL;
    rl_disturb_float_t* mat_src = (rl_disturb_float_t*)(void*)mat;
    Matrix mat_value;
    memset(&mat_value, 0, sizeof(mat_value));
    mat_value.m0 = (float)mat_src[0];
    mat_value.m1 = (float)mat_src[1];
    mat_value.m2 = (float)mat_src[2];
    mat_value.m3 = (float)mat_src[3];
    mat_value.m4 = (float)mat_src[4];
    mat_value.m5 = (float)mat_src[5];
    mat_value.m6 = (float)mat_src[6];
    mat_value.m7 = (float)mat_src[7];
    mat_value.m8 = (float)mat_src[8];
    mat_value.m9 = (float)mat_src[9];
    mat_value.m10 = (float)mat_src[10];
    mat_value.m11 = (float)mat_src[11];
    mat_value.m12 = (float)mat_src[12];
    mat_value.m13 = (float)mat_src[13];
    mat_value.m14 = (float)mat_src[14];
    mat_value.m15 = (float)mat_src[15];
    SetShaderValueMatrix(shader_value, (int)locIndex, mat_value);
    return NULL;
}

void* rl2_SetShaderValueTexture(void* shader, int32_t locIndex, void* texture) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    SetShaderValueTexture(shader_value, (int)locIndex, texture_value);
    return NULL;
}

void* rl2_SetShaderValueV(void* shader, int32_t locIndex, void* value, int32_t uniformType, int32_t count) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    SetShaderValueV(shader_value, (int)locIndex, (const void*)value, (int)uniformType, (int)count);
    return NULL;
}

void* rl2_SetShapesTexture(void* texture, float source_x, float source_y, float source_w, float source_h) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle source = { source_x, source_y, source_w, source_h };
    SetShapesTexture(texture_value, source);
    return NULL;
}

void* rl2_SetSoundPan(void* sound, float pan) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    SetSoundPan(sound_value, (float)pan);
    return NULL;
}

void* rl2_SetSoundPitch(void* sound, float pitch) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    SetSoundPitch(sound_value, (float)pitch);
    return NULL;
}

void* rl2_SetSoundVolume(void* sound, float volume) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    SetSoundVolume(sound_value, (float)volume);
    return NULL;
}

void* rl2_SetTargetFPS(int32_t fps) {
    SetTargetFPS((int)fps);
    return NULL;
}

void* rl2_SetTextLineSpacing(int32_t spacing) {
    SetTextLineSpacing((int)spacing);
    return NULL;
}

void* rl2_SetTextureFilter(void* texture, int32_t filter) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    SetTextureFilter(texture_value, (int)filter);
    return NULL;
}

void* rl2_SetTextureWrap(void* texture, int32_t wrap) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    SetTextureWrap(texture_value, (int)wrap);
    return NULL;
}

void* rl2_SetTraceLogLevel(int32_t logLevel) {
    SetTraceLogLevel((int)logLevel);
    return NULL;
}

void* rl2_SetWindowFocused(void) {
    SetWindowFocused();
    return NULL;
}

void* rl2_SetWindowIcon(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    SetWindowIcon(image_value);
    return NULL;
}

void* rl2_SetWindowIcons(void* images, int32_t count) {
    SetWindowIcons((Image*)images, (int)count);
    return NULL;
}

void* rl2_SetWindowMaxSize(int32_t width, int32_t height) {
    SetWindowMaxSize((int)width, (int)height);
    return NULL;
}

void* rl2_SetWindowMinSize(int32_t width, int32_t height) {
    SetWindowMinSize((int)width, (int)height);
    return NULL;
}

void* rl2_SetWindowMonitor(int32_t monitor) {
    SetWindowMonitor((int)monitor);
    return NULL;
}

void* rl2_SetWindowOpacity(float opacity) {
    SetWindowOpacity((float)opacity);
    return NULL;
}

void* rl2_SetWindowPosition(int32_t x, int32_t y) {
    SetWindowPosition((int)x, (int)y);
    return NULL;
}

void* rl2_SetWindowSize(int32_t width, int32_t height) {
    SetWindowSize((int)width, (int)height);
    return NULL;
}

void* rl2_SetWindowState(int32_t flags) {
    SetWindowState((unsigned int)flags);
    return NULL;
}

void* rl2_SetWindowTitle(char* title) {
    SetWindowTitle((const char*)title);
    return NULL;
}

void* rl2_ShowCursor(void) {
    ShowCursor();
    return NULL;
}

void* rl2_StartAutomationEventRecording(void) {
    StartAutomationEventRecording();
    return NULL;
}

void* rl2_StopAudioStream(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    StopAudioStream(stream_value);
    return NULL;
}

void* rl2_StopAutomationEventRecording(void) {
    StopAutomationEventRecording();
    return NULL;
}

void* rl2_StopMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    StopMusicStream(music_value);
    return NULL;
}

void* rl2_StopSound(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    StopSound(sound_value);
    return NULL;
}

void* rl2_SwapScreenBuffer(void) {
    SwapScreenBuffer();
    return NULL;
}

void* rl2_TakeScreenshot(char* fileName) {
    TakeScreenshot((const char*)fileName);
    return NULL;
}

void* rl2_TextAppend(char* text, char* append, int32_t* position, int32_t position_len) {
    if (position_len < 1) return NULL;
    if (position == NULL) return NULL;
    TextAppend((char*)text, (const char*)append, (int*)position);
    return NULL;
}

int32_t rl2_TextCopy(char* dst, char* src) {
    return (int32_t)TextCopy((char*)dst, (const char*)src);
}

int32_t rl2_TextFindIndex(char* text, char* search) {
    return (int32_t)TextFindIndex((const char*)text, (const char*)search);
}

char* rl2_TextInsert(char* text, char* insert, int32_t position) {
    return (char*)TextInsert((const char*)text, (const char*)insert, (int)position);
}

int32_t rl2_TextIsEqual(char* text1, char* text2) {
    return TextIsEqual((const char*)text1, (const char*)text2) ? 1 : 0;
}

char* rl2_TextJoin(void* textList, int32_t count, char* delimiter) {
    return (char*)TextJoin((char**)textList, (int)count, (const char*)delimiter);
}

int32_t rl2_TextLength(char* text) {
    return (int32_t)TextLength((const char*)text);
}

char* rl2_TextRemoveSpaces(char* text) {
    return (char*)TextRemoveSpaces((const char*)text);
}

char* rl2_TextReplace(char* text, char* search, char* replacement) {
    return (char*)TextReplace((const char*)text, (const char*)search, (const char*)replacement);
}

char* rl2_TextReplaceBetween(char* text, char* begin, char* end, char* replacement) {
    return (char*)TextReplaceBetween((const char*)text, (const char*)begin, (const char*)end, (const char*)replacement);
}

char* rl2_TextSplit(char* text, int32_t delimiter, int32_t* count, int32_t count_len) {
    if (count_len < 1) return NULL;
    if (count == NULL) return NULL;
    return (char*)TextSplit((const char*)text, (char)delimiter, (int*)count);
}

char* rl2_TextSubtext(char* text, int32_t position, int32_t length) {
    return (char*)TextSubtext((const char*)text, (int)position, (int)length);
}

char* rl2_TextToCamel(char* text) {
    return (char*)TextToCamel((const char*)text);
}

float rl2_TextToFloat(char* text) {
    return (float)TextToFloat((const char*)text);
}

int32_t rl2_TextToInteger(char* text) {
    return (int32_t)TextToInteger((const char*)text);
}

char* rl2_TextToLower(char* text) {
    return (char*)TextToLower((const char*)text);
}

char* rl2_TextToPascal(char* text) {
    return (char*)TextToPascal((const char*)text);
}

char* rl2_TextToSnake(char* text) {
    return (char*)TextToSnake((const char*)text);
}

char* rl2_TextToUpper(char* text) {
    return (char*)TextToUpper((const char*)text);
}

void* rl2_ToggleBorderlessWindowed(void) {
    ToggleBorderlessWindowed();
    return NULL;
}

void* rl2_ToggleFullscreen(void) {
    ToggleFullscreen();
    return NULL;
}

void* rl2_UnloadAudioStream(void* stream) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    UnloadAudioStream(stream_value);
    if (stream != NULL) free(stream);
    return NULL;
}

void* rl2_UnloadAutomationEventList(void* list) {
    AutomationEventList list_value;
    memset(&list_value, 0, sizeof(list_value));
    if (list != NULL) {
        list_value = *((AutomationEventList*)list);
    }
    UnloadAutomationEventList(list_value);
    if (list != NULL) free(list);
    return NULL;
}

void* rl2_UnloadCodepoints(void* codepoints) {
    UnloadCodepoints((int*)codepoints);
    return NULL;
}

void* rl2_UnloadDirectoryFiles(void* files) {
    FilePathList files_value;
    memset(&files_value, 0, sizeof(files_value));
    if (files != NULL) {
        files_value = *((FilePathList*)files);
    }
    UnloadDirectoryFiles(files_value);
    if (files != NULL) free(files);
    return NULL;
}

void* rl2_UnloadDroppedFiles(void* files) {
    FilePathList files_value;
    memset(&files_value, 0, sizeof(files_value));
    if (files != NULL) {
        files_value = *((FilePathList*)files);
    }
    UnloadDroppedFiles(files_value);
    if (files != NULL) free(files);
    return NULL;
}

void* rl2_UnloadFileData(void* data) {
    UnloadFileData((unsigned char*)data);
    return NULL;
}

void* rl2_UnloadFileText(char* text) {
    UnloadFileText((char*)text);
    return NULL;
}

void* rl2_UnloadFont(void* font) {
    Font font_value;
    memset(&font_value, 0, sizeof(font_value));
    if (font != NULL) {
        font_value = *((Font*)font);
    }
    UnloadFont(font_value);
    if (font != NULL) free(font);
    return NULL;
}

void* rl2_UnloadFontData(void* glyphs, int32_t glyphCount) {
    UnloadFontData((GlyphInfo*)glyphs, (int)glyphCount);
    return NULL;
}

void* rl2_UnloadImage(void* image) {
    Image image_value;
    memset(&image_value, 0, sizeof(image_value));
    if (image != NULL) {
        image_value = *((Image*)image);
    }
    UnloadImage(image_value);
    if (image != NULL) free(image);
    return NULL;
}

void* rl2_UnloadImageColors(void* colors) {
    UnloadImageColors((Color*)colors);
    return NULL;
}

void* rl2_UnloadImagePalette(void* colors) {
    UnloadImagePalette((Color*)colors);
    return NULL;
}

void* rl2_UnloadMaterial(void* material) {
    Material material_value;
    memset(&material_value, 0, sizeof(material_value));
    if (material != NULL) {
        material_value = *((Material*)material);
    }
    UnloadMaterial(material_value);
    if (material != NULL) free(material);
    return NULL;
}

void* rl2_UnloadMesh(void* mesh) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    UnloadMesh(mesh_value);
    if (mesh != NULL) free(mesh);
    return NULL;
}

void* rl2_UnloadModel(void* model) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    UnloadModel(model_value);
    if (model != NULL) free(model);
    return NULL;
}

void* rl2_UnloadModelAnimation(void* anim) {
    ModelAnimation anim_value;
    memset(&anim_value, 0, sizeof(anim_value));
    if (anim != NULL) {
        anim_value = *((ModelAnimation*)anim);
    }
    UnloadModelAnimation(anim_value);
    if (anim != NULL) free(anim);
    return NULL;
}

void* rl2_UnloadModelAnimations(void* animations, int32_t animCount) {
    UnloadModelAnimations((ModelAnimation*)animations, (int)animCount);
    return NULL;
}

void* rl2_UnloadMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    UnloadMusicStream(music_value);
    if (music != NULL) free(music);
    return NULL;
}

void* rl2_UnloadRandomSequence(void* sequence) {
    UnloadRandomSequence((int*)sequence);
    return NULL;
}

void* rl2_UnloadRenderTexture(void* target) {
    RenderTexture2D target_value;
    memset(&target_value, 0, sizeof(target_value));
    if (target != NULL) {
        target_value = *((RenderTexture2D*)target);
    }
    UnloadRenderTexture(target_value);
    if (target != NULL) free(target);
    return NULL;
}

void* rl2_UnloadShader(void* shader) {
    Shader shader_value;
    memset(&shader_value, 0, sizeof(shader_value));
    if (shader != NULL) {
        shader_value = *((Shader*)shader);
    }
    UnloadShader(shader_value);
    if (shader != NULL) free(shader);
    return NULL;
}

void* rl2_UnloadSound(void* sound) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    UnloadSound(sound_value);
    if (sound != NULL) free(sound);
    return NULL;
}

void* rl2_UnloadSoundAlias(void* alias) {
    Sound alias_value;
    memset(&alias_value, 0, sizeof(alias_value));
    if (alias != NULL) {
        alias_value = *((Sound*)alias);
    }
    UnloadSoundAlias(alias_value);
    if (alias != NULL) free(alias);
    return NULL;
}

void* rl2_UnloadTextLines(void* text, int32_t lineCount) {
    UnloadTextLines((char**)text, (int)lineCount);
    return NULL;
}

void* rl2_UnloadTexture(void* texture) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    UnloadTexture(texture_value);
    if (texture != NULL) free(texture);
    return NULL;
}

void* rl2_UnloadUTF8(char* text) {
    UnloadUTF8((char*)text);
    return NULL;
}

void* rl2_UnloadVrStereoConfig(void* config) {
    VrStereoConfig config_value;
    memset(&config_value, 0, sizeof(config_value));
    if (config != NULL) {
        config_value = *((VrStereoConfig*)config);
    }
    UnloadVrStereoConfig(config_value);
    if (config != NULL) free(config);
    return NULL;
}

void* rl2_UnloadWave(void* wave) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    UnloadWave(wave_value);
    if (wave != NULL) free(wave);
    return NULL;
}

void* rl2_UnloadWaveSamples(void* samples) {
    UnloadWaveSamples((float*)samples);
    return NULL;
}

void* rl2_UpdateAudioStream(void* stream, void* data, int32_t frameCount) {
    AudioStream stream_value;
    memset(&stream_value, 0, sizeof(stream_value));
    if (stream != NULL) {
        stream_value = *((AudioStream*)stream);
    }
    UpdateAudioStream(stream_value, (const void*)data, (int)frameCount);
    return NULL;
}

void* rl2_UpdateCamera(void* camera, int32_t mode) {
    UpdateCamera((Camera*)camera, (int)mode);
    return NULL;
}

void* rl2_UpdateCameraPro(void* camera, float movement_x, float movement_y, float movement_z, float rotation_x, float rotation_y, float rotation_z, float zoom) {
    Vector3 movement = { movement_x, movement_y, movement_z };
    Vector3 rotation = { rotation_x, rotation_y, rotation_z };
    UpdateCameraPro((Camera*)camera, movement, rotation, (float)zoom);
    return NULL;
}

void* rl2_UpdateMeshBuffer(void* mesh, int32_t index, void* data, int32_t dataSize, int32_t offset) {
    Mesh mesh_value;
    memset(&mesh_value, 0, sizeof(mesh_value));
    if (mesh != NULL) {
        mesh_value = *((Mesh*)mesh);
    }
    UpdateMeshBuffer(mesh_value, (int)index, (const void*)data, (int)dataSize, (int)offset);
    return NULL;
}

void* rl2_UpdateModelAnimation(void* model, void* anim, int32_t frame) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    ModelAnimation anim_value;
    memset(&anim_value, 0, sizeof(anim_value));
    if (anim != NULL) {
        anim_value = *((ModelAnimation*)anim);
    }
    UpdateModelAnimation(model_value, anim_value, (int)frame);
    return NULL;
}

void* rl2_UpdateModelAnimationBones(void* model, void* anim, int32_t frame) {
    Model model_value;
    memset(&model_value, 0, sizeof(model_value));
    if (model != NULL) {
        model_value = *((Model*)model);
    }
    ModelAnimation anim_value;
    memset(&anim_value, 0, sizeof(anim_value));
    if (anim != NULL) {
        anim_value = *((ModelAnimation*)anim);
    }
    UpdateModelAnimationBones(model_value, anim_value, (int)frame);
    return NULL;
}

void* rl2_UpdateMusicStream(void* music) {
    Music music_value;
    memset(&music_value, 0, sizeof(music_value));
    if (music != NULL) {
        music_value = *((Music*)music);
    }
    UpdateMusicStream(music_value);
    return NULL;
}

void* rl2_UpdateSound(void* sound, void* data, int32_t sampleCount) {
    Sound sound_value;
    memset(&sound_value, 0, sizeof(sound_value));
    if (sound != NULL) {
        sound_value = *((Sound*)sound);
    }
    UpdateSound(sound_value, (const void*)data, (int)sampleCount);
    return NULL;
}

void* rl2_UpdateTexture(void* texture, void* pixels) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    UpdateTexture(texture_value, (const void*)pixels);
    return NULL;
}

void* rl2_UpdateTextureRec(void* texture, float rec_x, float rec_y, float rec_w, float rec_h, void* pixels) {
    Texture2D texture_value;
    memset(&texture_value, 0, sizeof(texture_value));
    if (texture != NULL) {
        texture_value = *((Texture2D*)texture);
    }
    Rectangle rec = { rec_x, rec_y, rec_w, rec_h };
    UpdateTextureRec(texture_value, rec, (const void*)pixels);
    return NULL;
}

void* rl2_UploadMesh(void* mesh, int32_t dynamic) {
    UploadMesh((Mesh*)mesh, (bool)dynamic);
    return NULL;
}

void* rl2_WaitTime(float seconds) {
    WaitTime((double)seconds);
    return NULL;
}

void* rl2_WaveCopy(void* wave) {
    Wave wave_value;
    memset(&wave_value, 0, sizeof(wave_value));
    if (wave != NULL) {
        wave_value = *((Wave*)wave);
    }
    Wave rl_value = WaveCopy(wave_value);
    Wave* rl_heap = (Wave*)malloc(sizeof(Wave));
    if (rl_heap == NULL) return NULL;
    *rl_heap = rl_value;
    return (void*)rl_heap;
}

void* rl2_WaveCrop(void* wave, int32_t initFrame, int32_t finalFrame) {
    WaveCrop((Wave*)wave, (int)initFrame, (int)finalFrame);
    return NULL;
}

void* rl2_WaveFormat(void* wave, int32_t sampleRate, int32_t sampleSize, int32_t channels) {
    WaveFormat((Wave*)wave, (int)sampleRate, (int)sampleSize, (int)channels);
    return NULL;
}

int32_t rl2_WindowShouldClose(void) {
    return WindowShouldClose() ? 1 : 0;
}

void* rl_ptr_identity(void* p) {
    return p;
}

int32_t rl_ptr_equal(void* a, void* b) {
    return (a == b) ? 1 : 0;
}

int32_t rl_ptr_hash(void* p) {
    uintptr_t v = (uintptr_t)p;
    return (int32_t)(uint32_t)(v ^ (v >> 32));
}

int32_t rl_str_len(char* s) {
    if (!s) return -1;
    return (int32_t)strlen(s);
}

int32_t rl_str_hash(char* s) {
    if (!s) return 0;
    uint32_t h = 2166136261u;
    for (const char* p = s; *p; p++) {
        h ^= (uint32_t)(unsigned char)*p;
        h *= 16777619u;
    }
    return (int32_t)h;
}

int32_t rl_str_check_nul(char* s, int32_t max) {
    if (!s || max <= 0) return 0;
    for (int32_t i = 0; i < max; i++) {
        if (s[i] == '\0') return 1;
    }
    return 0;
}

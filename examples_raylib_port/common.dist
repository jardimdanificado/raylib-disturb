// Shared helpers for raylib official-example ports in Disturb.

eval(read("generated/raylib_ffi_phase3.dist"));

port_rgba = (r, g, b, a){
  return ((r & 255) << 24) | ((g & 255) << 16) | ((b & 255) << 8) | (a & 255);
};

PORT_RAYWHITE  = port_rgba(245, 245, 245, 255);
PORT_LIGHTGRAY = port_rgba(200, 200, 200, 255);
PORT_GRAY      = port_rgba(130, 130, 130, 255);
PORT_DARKGRAY  = port_rgba(80, 80, 80, 255);
PORT_BLACK     = port_rgba(0, 0, 0, 255);
PORT_RED       = port_rgba(230, 41, 55, 255);
PORT_MAROON    = port_rgba(190, 33, 55, 255);
PORT_GREEN     = port_rgba(0, 228, 48, 255);
PORT_LIME      = port_rgba(0, 158, 47, 255);
PORT_BLUE      = port_rgba(0, 121, 241, 255);
PORT_DARKBLUE  = port_rgba(0, 82, 172, 255);
PORT_YELLOW    = port_rgba(253, 249, 0, 255);
PORT_GOLD      = port_rgba(255, 203, 0, 255);
PORT_ORANGE    = port_rgba(255, 161, 0, 255);
PORT_PURPLE    = port_rgba(200, 122, 255, 255);
PORT_VIOLET    = port_rgba(135, 60, 190, 255);
PORT_BROWN     = port_rgba(127, 106, 79, 255);
PORT_BEIGE     = port_rgba(211, 176, 131, 255);
PORT_PINK      = port_rgba(255, 109, 194, 255);
PORT_SKYBLUE   = port_rgba(102, 191, 255, 255);
PORT_WHITE     = port_rgba(255, 255, 255, 255);

PORT_KEY_ESCAPE    = 256;
PORT_KEY_ENTER     = 257;
PORT_KEY_BACKSPACE = 259;
PORT_KEY_RIGHT     = 262;
PORT_KEY_LEFT      = 263;
PORT_KEY_DOWN      = 264;
PORT_KEY_UP        = 265;
PORT_KEY_A         = 65;
PORT_KEY_D         = 68;
PORT_KEY_S         = 83;
PORT_KEY_W         = 87;
PORT_KEY_SPACE     = 32;

PORT_MOUSE_LEFT_BUTTON = 0;

port_has_display = (){
  if (system("test -n \"$DISTURB_HEADLESS\"") == 0) { return 0; }
  if (system("test -n \"$DISPLAY\"") != 0) { return 0; }
  if (system("xdpyinfo >/dev/null 2>&1") != 0) { return 0; }
  return 1;
};

port_has_asset = (path){
  return system("test -f " + path) == 0;
};

port_pass = (name){
  println("PASS " + name);
};

port_pass_headless = (name){
  println("PASS_HEADLESS " + name);
};

port_pass_windowed = (name){
  println("PASS_WINDOWED " + name);
};

port_skip = (name, reason){
  println("SKIP " + name + ": " + reason);
};

port_fail = (name, reason){
  println("FAIL " + name + ": " + reason);
};

port_window_begin = (w, h, title){
  raylib_phase3.rl2_InitWindow(w, h, title);
  raylib_phase3.rl2_SetTargetFPS(60);
};

port_window_end = (){
  raylib_phase3.rl2_CloseWindow();
};

// Offscreen helpers
// NOTE: RenderTexture/Image handle roundtrip is unstable in current Disturb FFI runtime,
// so headless mode uses a deterministic software framebuffer fallback.
port_offscreen_mode = (){
  if (port_has_display() == 1) { return "windowed"; }
  return "headless_software";
};

port_offscreen_available = (){ return 1; };

port_abs = (v){ if (v < 0) { return -v; } return v; };

port_canvas_index = (cv, x, y){
  return 2 + (y * cv[0]) + x;
};

port_plot = (cv, x, y, color){
  w = cv[0];
  h = cv[1];
  if (x >= 0 && x < w && y >= 0 && y < h) {
    cv[port_canvas_index(cv, x, y)] = color;
  }
};

beginOffscreen = (w, h){
  return beginOffscreenColor(w, h, PORT_RAYWHITE);
};

beginOffscreenColor = (w, h, bgColor){
  cv = [0];
  cv.size = 2 + (w * h);
  cv[0] = w;
  cv[1] = h;
  i = 2;
  while (i < cv.size) {
    cv[i] = bgColor;
    i = i + 1;
  }
  return cv;
};

endOffscreen = (cv){
  // No-op for software offscreen mode.
  return 0;
};

offscreenClear = (cv, bgColor){
  i = 2;
  while (i < cv.size) {
    cv[i] = bgColor;
    i = i + 1;
  }
};

offscreenDrawRect = (cv, x, y, w, h, color){
  yy = y;
  while (yy < (y + h)) {
    xx = x;
    while (xx < (x + w)) {
      port_plot(cv, xx, yy, color);
      xx = xx + 1;
    }
    yy = yy + 1;
  }
};

offscreenDrawRectLines = (cv, x, y, w, h, color){
  offscreenDrawLine(cv, x, y, x + w - 1, y, color);
  offscreenDrawLine(cv, x, y + h - 1, x + w - 1, y + h - 1, color);
  offscreenDrawLine(cv, x, y, x, y + h - 1, color);
  offscreenDrawLine(cv, x + w - 1, y, x + w - 1, y + h - 1, color);
};

offscreenDrawLine = (cv, x0, y0, x1, y1, color){
  dx = port_abs(x1 - x0);
  dy = -port_abs(y1 - y0);
  sx = 1;
  if (x0 > x1) { sx = -1; }
  sy = 1;
  if (y0 > y1) { sy = -1; }
  err = dx + dy;

  while (1) {
    port_plot(cv, x0, y0, color);
    if (x0 == x1 && y0 == y1) { break; }
    e2 = 2 * err;
    if (e2 >= dy) {
      err = err + dy;
      x0 = x0 + sx;
    }
    if (e2 <= dx) {
      err = err + dx;
      y0 = y0 + sy;
    }
  }
};

offscreenDrawCircle = (cv, cx, cy, radius, color){
  r2 = radius * radius;
  yy = -radius;
  while (yy <= radius) {
    xx = -radius;
    while (xx <= radius) {
      if ((xx * xx) + (yy * yy) <= r2) {
        port_plot(cv, cx + xx, cy + yy, color);
      }
      xx = xx + 1;
    }
    yy = yy + 1;
  }
};

offscreenDrawText = (cv, text, x, y, fontSize, color){
  chars = raylib_phase3.rl2_TextLength(text);
  tw = chars * (fontSize / 2);
  if (tw < 1) { tw = fontSize; }
  th = fontSize;
  if (th < 1) { th = 1; }
  offscreenDrawRect(cv, x, y, tw, th, color);
};

readPixel = (cv, x, y){
  if (x < 0 || x >= cv[0] || y < 0 || y >= cv[1]) { return -1; }
  return cv[port_canvas_index(cv, x, y)];
};

countNonBackground = (cv, bgColor){
  count = 0;
  i = 2;
  while (i < cv.size) {
    if (cv[i] != bgColor) { count = count + 1; }
    i = i + 1;
  }
  return count;
};

assertPixelEquals = (name, cv, x, y, expected){
  got = readPixel(cv, x, y);
  if (got != expected) {
    port_fail(name, "pixel mismatch at (" + x + "," + y + ") expected=" + expected + " got=" + got);
    return 0;
  }
  return 1;
};

assertPixelNotEquals = (name, cv, x, y, unexpected){
  got = readPixel(cv, x, y);
  if (got == unexpected) {
    port_fail(name, "unexpected pixel at (" + x + "," + y + ") value=" + got);
    return 0;
  }
  return 1;
};
